<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[bxbxbai’s notes]]></title>
  <subtitle><![CDATA[学会用不同的角度去看待和理解这个世界，你收获的永远比你想象的更多]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://bxbxbai.gitcafe.io/"/>
  <updated>2015-10-06T08:17:16.000Z</updated>
  <id>http://bxbxbai.gitcafe.io/</id>
  
  <author>
    <name><![CDATA[bxbxbai]]></name>
    <email><![CDATA[bxbxbai@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[为什么技术团队应该写博客？]]></title>
    <link href="http://bxbxbai.gitcafe.io/2015/09/29/why-a-team-should-write-a-blog/"/>
    <id>http://bxbxbai.gitcafe.io/2015/09/29/why-a-team-should-write-a-blog/</id>
    <published>2015-09-29T11:16:25.000Z</published>
    <updated>2015-10-06T08:17:16.000Z</updated>
    <content type="html"><![CDATA[<p>我本人平时很喜欢看一些博客，包括技术的和非技术的，慢慢也积累了很多博客列表，包括个人的和团队的</p>
<p>很久以前我看到过大神刘未鹏写的文章：<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">为什么你应该（从现在开始就）写博客</a>，文中很多道理直到我也开始写博客的时候才慢慢领悟到。比如，我可能对一个技术或概念很熟悉了，但是当我要说出来或者写下来给别人看的时候，就会发现有些技术的细节没考虑清楚。因此，当你写一篇博客的时候，其实你就是在逼迫你自己去把每一个细节都弄清楚</p>
<a id="more"></a>
<h2 id="国内外的技术博客">国内外的技术博客</h2><p>我也列举一些我收藏的，也经常会看的博客（排序不分先后）。</p>
<h3 id="Facebook">Facebook</h3><p>网址：<a href="https://code.facebook.com" target="_blank" rel="external">https://code.facebook.com</a><br>博客上会介绍一些Facebook在Android、iOS、前端、后端以及硬件技术遇到的问题，也包括一些他们团队研究的新技术，比如<code>fresco</code>等等。我最感兴趣的是他们在技术上遇到的一些问题，然后他们是怎么解决的</p>
<h3 id="Square">Square</h3><p>网址：<a href="http://square.github.io/" target="_blank" rel="external">http://square.github.io/</a><br>Square应该是业界开源项目最多的公司之一了，它的github主页上列举了好多开源项目，一个做Android的如果没用过Square的开源库的话，要么你非常非常牛逼，要么你真的不关心开源项目</p>
<h3 id="美团">美团</h3><p>网址：<a href="http://tech.meituan.com/" target="_blank" rel="external">http://tech.meituan.com/</a><br>从它的博客可以看到美团大概是从2013开慢慢写的，大概是因为2013后美团不断扩大，也慢慢积累了很多技术（踩了很多坑），博客上会写各种技术的：Android、iOS、前端、运维、机器学习等等~</p>
<h3 id="阿里">阿里</h3><p>网址：<a href="http://jaq.alibaba.com/" target="_blank" rel="external">阿里聚安全</a><br>抱歉我没有找到阿里公开的技术博客站点，之前我在阿里的时候，我在内网看到，公司内部会有很多人分享自己遇到的问题以及解决方法，公开的博客，我还没有发现</p>
<h3 id="微信移动团队">微信移动团队</h3><p>这个应该没有博客，只有微信公众号：WeMobileDev<br>貌似也是最近才开的，博客文章的质量非常高，每一篇基本都是微信移动团队经验的总结，详细介绍了他们遇到的困难以及如何解决的。比如：提升Android客户端会话速度提升70%背后的故事、Android微信只能心跳方案、Android拆分与加载Dex的多种方案等等</p>
<p>每一篇都会具体到技术的细节，真正的解决每一个问题，非常赞这样的技术团队</p>
<h3 id="腾讯的bugly">腾讯的bugly</h3><p>网址：<a href="http://bugly.qq.com/blog/" target="_blank" rel="external">http://bugly.qq.com/blog/</a><br>Bugly的博客会介绍一些Android和iOS开发过程中帮助我们性能分析的方法，比如如何衡量一个App的卡顿情况呢？Bugly的博客告诉你，使用<code>Choreographer.FrameCallback</code>这个工具。还有很多其他的性能分析的技巧</p>
<h2 id="为什么要开始写博客">为什么要开始写博客</h2><p>刘未鹏的文章其实已经回答了这个问题，那是一篇非常好的文章。</p>
<p>不过我还是想说说我自己的想法：</p>
<p>首先，可以有技术沉淀。一个公司或者技术团队（简称团队）肯定在业务发展的过程中会遇到并且解决很多的技术难题，如果把这些经验记下来，并且对外公布（如果没有涉及公司机密的话），这样会让很多人受益。</p>
<p>其次，可以促进技术交流，然后吸引公司外部喜欢技术的人加入公司。我始终相信，一个热爱技术的人，肯定是喜欢和技术牛X的人待一起工作的。而且，我也相信，当一个人真正喜欢技术以后，在走路或者吃饭的时候谈技术都是很平常的事情。比如，像微信移动团队那样，输出高质量的技术文章，是肯定可以吸引到热爱技术的人，这样的话团队只会越来越强</p>
<p>最后，<a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/" target="_blank" rel="external">写作是为了更好的思考</a>。这是刘未鹏说的，书写可以让你整理你思考的内容，写下来和我自己想想还是有很大区别的。写作还可以激励团队持续的学习，技术在不断发展，技术难题也在不断增加，让团队持续学习才是根本呀</p>
<h2 id="最后">最后</h2><p>从上面的博客中可以看到，优秀的技术公司是总结并且分享自己经验，然而卓越而伟大的技术公司，比如Facebook和Square等，是在创造新的技术，比如<code>fresco</code>、<code>stetho</code>、<code>okhttp</code>和<code>retrofit</code>等等</p>
<p>我是相信一些技术牛逼或者正在成为技术牛逼的人都是发自内心的喜欢技术，可能开始ta的技术并不是很厉害，但是ta会花空余的时间去了解并且研究一些新的技术。然后，自己不断总结和反思，这样的人对一个团队和公司都是一种财富</p>
<p>我自己有体会，之前遇到的难题，我解决了，如果不总结一下，有些会随着时间慢慢忘记掉，所以我自己写博客很大一部分原因也是为了自己以后来温故自己的经验</p>
<p>如果你经常看不错的技术博客，欢迎和我分享~</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>我本人平时很喜欢看一些博客，包括技术的和非技术的，慢慢也积累了很多博客列表，包括个人的和团队的</p>
<p>很久以前我看到过大神刘未鹏写的文章：<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/">为什么你应该（从现在开始就）写博客</a>，文中很多道理直到我也开始写博客的时候才慢慢领悟到。比如，我可能对一个技术或概念很熟悉了，但是当我要说出来或者写下来给别人看的时候，就会发现有些技术的细节没考虑清楚。因此，当你写一篇博客的时候，其实你就是在逼迫你自己去把每一个细节都弄清楚</p>]]>
    
    </summary>
    
      <category term="杂感" scheme="http://bxbxbai.gitcafe.io/tags/%E6%9D%82%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谈谈App混合开发]]></title>
    <link href="http://bxbxbai.gitcafe.io/2015/08/16/talk-about-bybird-app/"/>
    <id>http://bxbxbai.gitcafe.io/2015/08/16/talk-about-bybird-app/</id>
    <published>2015-08-16T08:07:11.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>混合开发的App（Hybrid App）就是在一个App中内嵌一个轻量级的浏览器，一部分原生的功能改为Html 5来开发，这部分功能不仅能够在不升级App的情况下动态更新，而且可以在Android或iOS的App上同时运行，让用户的体验更好又可以节省开发的资源。</p>
<p>下面来谈谈Hybrid App开发中的技术问题。iOS方面的我不太了解，我就主要谈谈Android开发中的，其中可能会有很多说错的，请大家轻喷</p>
<a id="more"></a>
<h1 id="Hybrid开发中关键问题是什么">Hybrid开发中关键问题是什么</h1><p>想要在一个App中显示一个Html 5网页的功能，其实很简单，只要一个WebView就可以了。你可以点击链接来跳转网页。像这样的功能就能叫做Hybrid 开发了嘛？显然不是的。</p>
<p><strong>我觉得一个Hybrid开发的App中必须要要有的功能就是Html 5页面和Native App怎么进行交互</strong>。比如，我点了一个Html 5页面上的一个按钮或链接，我能不能够跳转到Native App的某个页面；比如我点了Html 5页面上的分享按钮，我能不能调用Native App的分享功能；比如Html加载的时候能不能获取Native App的用户信息等等。</p>
<p>看下图，在网易云音乐中进入这个Html 5页面时，你点击<strong>作者：空虚小编</strong>你会进入他的主页，这个主页是Native页面，而你点击上面那个播放按钮时，云音乐会启动Native的播放界面播放音乐，你点击评论时，你会进入Native的评论页</p>
<p><img src="http://i1.tietuku.com/5575cfa4108a1f0e.png" alt="此处输入图片的描述"></p>
<h1 id="Html_5和Native的交互">Html 5和Native的交互</h1><p><code>WebView</code>本来就支持js和Java相互调用，你只需要开启<code>WebView</code>的JavaScript脚本执行，然后通过代码<code>mWebView.addJavascriptInterface(new JsBridge(), &quot;bxbxbai&quot;);</code>向Html 5页面时注入一个Java对象，然后就可以在Html 5页面中调用Native的功能了</p>
<h2 id="微信怎么做的">微信怎么做的</h2><p>微信应该是Hybrid 开发做的最好的App之一，它是怎么做交互的呢？</p>
<p>答案就是<code>微信JS-SDK</code>，去微信开发者文档中可以看到，微信JS-SDK封装了各种微信的功能，比如分享到朋友圈，图像接口，音频接口，支付接口地理位置接口等等。开发者只需要调用微信JS-SDK中的函数，然后统一由JS-SDK来调用微信中的功能，这样好处就是我写了一个Html 5的应用或网页，在Android和iOS的微信中都可以正常运行了</p>
<p>下面会详细讲到</p>
<h2 id="网易云音乐怎么做的">网易云音乐怎么做的</h2><p>那么网易云音乐是怎么做的呢？我用黑科技知道了上图云音乐的界面Activity是<code>CommonSubjectActivity</code>（名字好奇怪，如果要我从代码里找，我肯定找不到，因为还有一个类叫做<code>EmbedBrowserActivity</code>），我就在反编译后的云音乐代码中找相应的功能实现代码，实在没找到。不过我拿到了那个Html 5页面的地址：<a href="http://music.163.com/m/topic/194001" target="_blank" rel="external">http://music.163.com/m/topic/194001</a></p>
<p>用Chrome打开后发现和App中显示的不一样，然后我用Charles截了进入那个Html 5的请求，发现云音乐加载的地址是<a href="http://music.163.com/m/topic/194001?type=android" target="_blank" rel="external">http://music.163.com/m/topic/194001?type=android</a> ，就是加了手机系统类型</p>
<p>然后在我自己的App中加载这个Html 5页面就可以看到下图，<strong>@小比比说</strong>这样的文字是可以点击跳转到个人，点击播放按钮是可以播放音乐的</p>
<p><img src="http://i3.tietuku.com/b00f74ef47f9ee0d.png" alt="此处输入图片的描述"></p>
<p>从Html源代码中可以看到如下信息：</p>
<p><img src="http://i3.tietuku.com/0197b3a47d0c2f1a.png" alt="此处输入图片的描述"></p>
<p>也就是说，当我点击一个用户名的时候就请求跳转到<code>orpheus://user/30868859</code>，因为WebView可以拦截跳转的url，所以App在拦截每一个url，如果host是<code>orpheus</code>的话就启动用户首页</p>
<p>反编译代码后，在云音乐的代码中找到了<code>this.mWebView.setWebViewClient(new cf(this));</code>这么一句代码，进入<code>cf</code>类，发现下面代码：</p>
<pre><code>public boolean shouldOverrideUrlLoading<span class="params">(WebView webView, String url)</span> {
    <span class="keyword">if</span> <span class="params">(url.startsWith<span class="params">(<span class="string">"orpheus://"</span>)</span>)</span> {
        RedirectActivity.a<span class="params">(this.activity, url)</span>;
        return <span class="literal">true</span>;
    }
    <span class="keyword">if</span> <span class="params">(<span class="params">(url.toLowerCase<span class="params">()</span>.startsWith<span class="params">(<span class="string">"http://"</span>)</span>)</span> || <span class="params">(url.toLowerCase<span class="params">()</span>.startsWith<span class="params">(<span class="string">"https://"</span>)</span>)</span>)</span> {
        return <span class="literal">false</span>;
    }
    try {
        this.activity.startActivity<span class="params">(new Intent<span class="params">(<span class="string">"android.intent.action.VIEW"</span>, Uri.parse<span class="params">(url)</span>)</span>)</span>;
        return <span class="literal">true</span>;
    } catch <span class="params">(ActivityNotFoundException localActivityNotFoundException)</span> {
        localActivityNotFoundException.printStackTrace<span class="params">()</span>;
    }
    return <span class="literal">true</span>;
}
</code></pre><p>果然如此，再进入<code>RedirectActivity</code>，这是一个没有任何界面的Activity，专门用于处理页面跳转信息，它会调用一个方法<code>NeteaseMusicUtils.redirect(this, getIntent().getData().toString(), false)</code>来处理url，<code>redirect</code>方法的名字是我自己写的，部分代码如下：</p>
<p><img src="http://i3.tietuku.com/99edcdc0195316cf.png" alt="此处输入图片的描述"></p>
<p>可以看到<code>orpheus://user/30868859</code>中的用户id被传入了<code>ProfileAcvitiy</code>，因此启动了用户首页显示了用户信息</p>
<p>然后我自己写了代码拦截Html 5的跳转，打印出的Log如下：</p>
<p><img src="http://i3.tietuku.com/68f3abf5eb92745c.png" alt="此处输入图片的描述"></p>
<p>可以看到Html 5页面可以跳转到各种页面，比如用户首页、播放音乐、MV界面、评论页、电台节目等等</p>
<h2 id="总结">总结</h2><p>一般来讲，也是我目前知道的两种主流的方式就是</p>
<ol>
<li>js调用Native中的代码</li>
<li>Schema：WebView拦截页面跳转</li>
</ol>
<p>第2种方式实现起来很简单，但是一个致命的问题就是这种交互方式是单向的，Html 5无法实现回调。像云音乐App中这种点击跳转到具体页面的功能，Schema的方式确实可以简单实现，而且也非常适合。如果需求变得复杂，假如Html 5需要获取Native App中的用户信息，那么最好使用js调用的方式。</p>
<h1 id="js和Native进行交互">js和Native进行交互</h1><p>上面讲到WebViewbe本身就是支持js调用Native代码的，不过WebView的这个功能在Android 4.2（API 17）一下存在高危的漏洞。这个漏洞的原理就是Android系统通过<code>WebView.addJavascriptInterface(Object o, String interface)</code>方法注册可供js调用的Java对象，但是系统并没有对注册的Java对象方法调用做限制。导致攻击者可以利用反射调用未注册的其他任何Java对象，攻击者可以根据客户端的能力做任何事情。<a href="http://jaq.alibaba.com/blog.htm?id=48" target="_blank" rel="external">这篇文章</a>详细的介绍了这个漏洞</p>
<p>出于安全考虑，Android 4.2以后的系统规定允许被js调用的Java方法必须以<code>@JavascriptInterface</code>进行注解</p>
<h2 id="Cordova的解决方案">Cordova的解决方案</h2><p>Cordova是一个广泛使用的Hybrid开发框架，它提供了一套js和Native交互规范</p>
<p>在Cordova的<code>SystemWebViewEngine</code>类中可以看到</p>
<pre><code><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">exposeJsInterface</span><span class="params">(WebView webView, CordovaBridge bridge)</span> </span>{
    <span class="keyword">if</span> ((Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN_MR1)) {
        Log.i(TAG, <span class="string">"Disabled addJavascriptInterface() bridge since Android version is old."</span>);
        <span class="comment">// Bug being that Java Strings do not get converted to JS strings automatically.</span>
        <span class="comment">// This isn't hard to work-around on the JS side, but it's easier to just</span>
        <span class="comment">// use the prompt bridge instead.</span>
        <span class="keyword">return</span>;
    }
    webView.addJavascriptInterface(<span class="keyword">new</span> SystemExposedJsApi(bridge), <span class="string">"_cordovaNative"</span>);
}
</code></pre><p>因此当Android系统高于4.2时，Cordova还是使用<code>addJavascriptInterface</code>这种方式，因为这个方法在高版本上安全而且简单，低于4.2的时候，用什么方法呢？</p>
<p><strong>答案是<code>WebChromeClient.onJsPrompt</code>方法</strong></p>
<p>WebView可以设置一个<code>WebChromeClient</code>对象，它可以处理js的3个方法</p>
<ul>
<li><code>onJsAlert</code></li>
<li><code>onJsConfirm</code></li>
<li><code>onJsPrompt</code></li>
</ul>
<p>这3个方法分别对应js的<code>alert</code>、<code>confirm</code>、<code>prompt</code>方法，因为只有<code>prompt</code>接收返回值，所以js调用一个Native方法后可以等待Native返回一个参数。下面是<code>cordova.js</code>中的一段代码：</p>
<pre><code><span class="comment">/**
* Implements the API of ExposedJsApi.java, but uses prompt() to communicate.
* This is used pre-JellyBean, where addJavascriptInterface() is disabled.
*/</span>
<span class="built_in">module</span>.exports = {
    exec: <span class="function"><span class="keyword">function</span>(<span class="params">bridgeSecret, service, action, callbackId, argsJson</span>) </span>{
        <span class="keyword">return</span> prompt(argsJson, <span class="string">'gap:'</span>+<span class="built_in">JSON</span>.stringify([bridgeSecret, service, action, callbackId]));
    },
    setNativeToJsBridgeMode: <span class="function"><span class="keyword">function</span>(<span class="params">bridgeSecret, value</span>) </span>{
        prompt(value, <span class="string">'gap_bridge_mode:'</span> + bridgeSecret);
    },
    retrieveJsMessages: <span class="function"><span class="keyword">function</span>(<span class="params">bridgeSecret, fromOnlineEvent</span>) </span>{
        <span class="keyword">return</span> prompt(+fromOnlineEvent, <span class="string">'gap_poll:'</span> + bridgeSecret);
    }
};
</code></pre><p>然后只要在<code>onJsPrompt</code>方法中使用<code>CordovaBridge</code>来处理js的prompt调用</p>
<pre><code>/**
 * <span class="type">Tell</span> the client to display a prompt dialog to the user. <span class="type">If</span> the client returns <span class="literal">true</span>, <span class="type">WebView</span> will assume that the client will handle the prompt dialog <span class="keyword">and</span> call the appropriate <span class="type">JsPromptResult</span> <span class="keyword">method</span>.
 * &lt;p/&gt;
 * <span class="type">Since</span> we are hacking prompts <span class="keyword">for</span> our own purposes, we should <span class="keyword">not</span> be <span class="keyword">using</span> them <span class="keyword">for</span> this purpose, perhaps we should hack console.log to <span class="keyword">do</span> this instead!
 */
@<span class="type">Override</span>
public boolean onJsPrompt(<span class="type">WebView</span> view, <span class="type">String</span> origin, <span class="type">String</span> message, <span class="type">String</span> defaultValue, final <span class="type">JsPromptResult</span> <span class="literal">result</span>) {
    // <span class="type">Unlike</span> the @<span class="type">JavascriptInterface</span> bridge, this <span class="keyword">method</span> <span class="keyword">is</span> always called on the <span class="type">UI</span> thread.
    <span class="type">String</span> handledRet = parentEngine.bridge.promptOnJsPrompt(origin, message, defaultValue);
    <span class="keyword">if</span> (handledRet != null) {
        <span class="literal">result</span>.confirm(handledRet);
    } <span class="keyword">else</span> {
        dialogsHelper.showPrompt(message, defaultValue, new <span class="type">CordovaDialogsHelper</span>.<span class="type">Result</span>() {
            @<span class="type">Override</span>
            public <span class="type">void</span> gotResult(boolean success, <span class="type">String</span> value) {
                <span class="keyword">if</span> (success) {
                    <span class="literal">result</span>.confirm(value);
                } <span class="keyword">else</span> {
                    <span class="literal">result</span>.cancel();
                }
            }
        });
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><h2 id="一种开源的解决方案">一种开源的解决方案</h2><p>Cordova是Apache的一个开源解决方案，不过它需要xml配置<code>CordovaPlugin</code>信息，使用会比较麻烦，而且这个框架很重，具体请自行搜索Cordova使用教程</p>
<p>下面这个开源项目是我个人觉得比较合理的解决方案，也比较轻量级，下图就是一个Demo</p>
<p><a href="https://github.com/pedant/safe-java-js-webview-bridge" target="_blank" rel="external">https://github.com/pedant/safe-java-js-webview-bridge</a></p>
<p><img src="http://i3.tietuku.com/14cc4af678f56eaf.png" alt="此处输入图片的描述"></p>
<p>这个项目的原理就是使用<code>WebChromeClient.onJsPrompt</code>方法来进行交互，本质上都是js调用<code>prompt</code>函数，传输一些参数，<code>onJsPrompt</code>方法拦截到prompt动作，然后解析数据，最后调用相应的Native方法</p>
<p><strong>HostJsScope</strong>类中定义了所有可以被js调用的方法，这些方法都必须是静态方法，并且所有的方法第一个参数必须是WebView</p>
<pre><code><span class="comment">/**
* HostJsScope中需要被JS调用的函数，必须定义成public static，且必须包含WebView这个参数
*/</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostJsScope</span> </span>{
    <span class="comment">/**
    * 短暂气泡提醒
    * <span class="doctag">@param</span> webView 浏览器
    * <span class="doctag">@param</span> message 提示信息
    * */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toast</span><span class="params">(WebView webView, String message)</span> </span>{
        Toast.makeText(webView.getContext(), message, Toast.LENGTH_SHORT).show();
    }

    <span class="comment">/**
    * 系统弹出提示框
    * <span class="doctag">@param</span> webView 浏览器
    * <span class="doctag">@param</span> message 提示信息
    * */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alert</span><span class="params">(WebView webView, String message)</span> </span>{
        <span class="comment">// 构建一个Builder来显示网页中的alert对话框</span>
        AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(webView.getContext());
        builder.setPositiveButton(android.R.string.ok, <span class="keyword">new</span> AlertDialog.OnClickListener() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>{
                dialog.dismiss();
            }
        });
        builder.setTitle(<span class="string">"Hello world"</span>)
            .setMessage(message)
            .setCancelable(<span class="keyword">false</span>)
            .create()
            .show();
    }

    <span class="comment">// 其他代码</span>

}
</code></pre><p>上面代码列举了最基本的点击Html 5按钮弹出对话框的功能</p>
<p>这个库中一个最关键的叫做<code>JsCallJava</code>，这个实现的就是js来调用Java方法的功能，这个类只用于<code>InjectedWebChromeClient</code>类</p>
<pre><code>public class <span class="type">InjectedChromeClient</span> extends <span class="type">WebChromeClient</span> {

    private <span class="type">JsCallJava</span> mJsCallJava;
    private boolean mIsInjectedJS;

    public <span class="type">InjectedChromeClient</span>(<span class="type">String</span> injectedName, <span class="type">Class</span> injectedCls) {
        this(new <span class="type">JsCallJava</span>(injectedName, injectedCls));
    }

    public <span class="type">InjectedChromeClient</span>(<span class="type">JsCallJava</span> jsCallJava) {
        mJsCallJava = jsCallJava;
    }

    // 处理<span class="type">Alert</span>事件
    @<span class="type">Override</span>
    public boolean onJsAlert(<span class="type">WebView</span> view, <span class="type">String</span> url, <span class="type">String</span> message, final <span class="type">JsResult</span> <span class="literal">result</span>) {
        <span class="literal">result</span>.confirm();
        <span class="keyword">return</span> <span class="literal">true</span>;
    }

    @<span class="type">Override</span>
    public <span class="type">void</span> onProgressChanged(<span class="type">WebView</span> view, <span class="type">int</span> newProgress) {
        //为什么要在这里注入<span class="type">JS</span>
        //<span class="number">1</span> <span class="type">OnPageStarted</span>中注入有可能全局注入不成功，导致页面脚本上所有接口任何时候都不可用
        //<span class="number">2</span> <span class="type">OnPageFinished</span>中注入，虽然最后都会全局注入成功，但是完成时间有可能太晚，当页面在初始化调用接口函数时会等待时间过长
        //<span class="number">3</span> 在进度变化时注入，刚好可以在上面两个问题中得到一个折中处理
        //为什么是进度大于<span class="number">25</span>%才进行注入，因为从测试看来只有进度大于这个数字页面才真正得到框架刷新加载，保证<span class="number">100</span>%注入成功
        <span class="keyword">if</span> (newProgress &lt;= <span class="number">25</span>) {
            mIsInjectedJS = <span class="literal">false</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (!mIsInjectedJS) {
            view.loadUrl(mJsCallJava.getPreloadInterfaceJS());
            mIsInjectedJS = <span class="literal">true</span>;
            <span class="type">StopWatch</span>.log(<span class="string">" inject js interface completely on progress "</span> + newProgress);
        }
        super.onProgressChanged(view, newProgress);
    }

    @<span class="type">Override</span>
    public boolean onJsPrompt(<span class="type">WebView</span> view, <span class="type">String</span> url, <span class="type">String</span> message, <span class="type">String</span> defaultValue, <span class="type">JsPromptResult</span> <span class="literal">result</span>) {
        <span class="literal">result</span>.confirm(mJsCallJava.call(view, message));
        <span class="type">StopWatch</span>.log(<span class="string">"onJsPrompt: "</span> + view.toString() +<span class="string">", "</span> + url +<span class="string">", "</span> + message +<span class="string">", "</span> + defaultValue + <span class="string">", "</span> + <span class="literal">result</span>) ;
        <span class="keyword">return</span> <span class="literal">true</span>;
    }
}   
</code></pre><p>这个<code>InjectedWebChromeClient</code>是设给WebView的，这里一个非常重要的细节需要注意一下，在<code>onProgressChange</code>方法中，向WebView注入了一段js代码，这段js代码如下：</p>
<pre><code>javascript: (function(b) {
    console.<span class="literal">log</span>(<span class="string">"HostApp initialization begin"</span>);
    <span class="keyword">var</span> a = {
        queue: [],
        callback: function() {
            <span class="keyword">var</span> <span class="keyword">d</span> = Array.prototype.slice.call(arguments, 0);
            <span class="keyword">var</span> c = <span class="keyword">d</span>.shift();
            <span class="keyword">var</span> <span class="keyword">e</span> = <span class="keyword">d</span>.shift();
            this.queue[c].apply(this, <span class="keyword">d</span>);
            <span class="keyword">if</span> (!<span class="keyword">e</span>) {
                delete this.queue[c]
            }
        }
    };
    a.alert = a.alert = a.alert = a.delayJsCallBack = a.getIMSI = a.getOsSdk = a.goBack = a.overloadMethod = a.overloadMethod 
        = a.passJson2Java = a.passLongType = a.retBackPassJson = a.retJavaObject = a.testLossTime = a.toast = a.toast = function() {
        <span class="keyword">var</span> f = Array.prototype.slice.call(arguments, 0);
        <span class="keyword">if</span> (f.length &lt; 1) {
            throw <span class="string">"HostApp call error, message:miss method name"</span>
        }
        <span class="keyword">var</span> <span class="keyword">e</span> = [];
        <span class="keyword">for</span> (<span class="keyword">var</span> <span class="keyword">h</span> = 1; <span class="keyword">h</span> &lt; f.length; <span class="keyword">h</span>++) {
            <span class="keyword">var</span> c = f[<span class="keyword">h</span>];
            <span class="keyword">var</span> j = <span class="keyword">typeof</span> c;
            <span class="keyword">e</span>[<span class="keyword">e</span>.length] = j;
            <span class="keyword">if</span> (j == <span class="string">"function"</span>) {
                <span class="keyword">var</span> <span class="keyword">d</span> = a.queue.length;
                a.queue[<span class="keyword">d</span>] = c;
                f[<span class="keyword">h</span>] = <span class="literal">d</span>
            }
        }
        <span class="keyword">var</span> <span class="keyword">g</span> = JSON.<span class="keyword">parse</span>(prompt(JSON.stringify({
            method: f.shift(),
            types: <span class="keyword">e</span>,
            <span class="keyword">args</span>: <span class="literal">f</span>
        })));
        <span class="keyword">if</span> (<span class="keyword">g</span>.code != 200) {
            throw <span class="string">"HostApp call error, code:"</span> + <span class="keyword">g</span>.code + <span class="string">", message:"</span> + <span class="keyword">g</span>.result
        }
        <span class="keyword">return</span> <span class="keyword">g</span>.result
    };
    <span class="comment">//有时候，我们希望在该方法执行前插入一些其他的行为用来检查当前状态或是监测</span>
    <span class="comment">//代码行为，这就要用到拦截（Interception）或者叫注入（Injection）技术了</span>
    <span class="comment">/**
     * Object.getOwnPropertyName 返回一个数组，内容是指定对象的所有属性
     *
     * 其后遍历这个数组，分别做以下处理：
     * 1. 备份原始属性；
     * 2. 检查属性是否为 function（即方法）；
     * 3. 若是重新定义该方法，做你需要做的事情，之后 apply 原来的方法体。
     */</span>
    Object.getOwnPropertyNames(a).<span class="keyword">forEach</span>(function(<span class="keyword">d</span>) {
        <span class="keyword">var</span> c = a[<span class="keyword">d</span>];
        <span class="keyword">if</span> (<span class="keyword">typeof</span> c === <span class="string">"function"</span> &amp;&amp; <span class="keyword">d</span> !== <span class="string">"callback"</span>) {
            a[<span class="keyword">d</span>] = function() {
                <span class="keyword">return</span> c.apply(a, [<span class="keyword">d</span>].concat(Array.prototype.slice.call(arguments, 0)))
            }
        }
    });
    b.HostApp = a;
    console.<span class="literal">log</span>(<span class="string">"HostApp initialization end"</span>)
})(<span class="keyword">window</span>);
</code></pre><p>那么这段js代码是如何生成的呢？答案就在<code>JsCallJava</code>类的构造函数方法中，这个构造方法做的事情就是解析<code>HostJsScope</code>类中的方法，把每一个方法的签名都保持到<code>private Map&lt;String, Method&gt; mMethodsMap</code>中，再看上面那段js代码中</p>
<blockquote>
<p>a.alert = a.alert = a.alert = a.delayJsCallBack = a.getIMSI = a.getOsSdk = a.goBack = a.overloadMethod = a.overloadMethod<br>            = a.passJson2Java = a.passLongType = a.retBackPassJson = a.retJavaObject = a.testLossTime = a.toast = a.toast = function()</p>
</blockquote>
<p>这些都是<code>HostJsScope</code>类中定义的方法名</p>
<p>那么这个库的整个执行流程是这样的：</p>
<ol>
<li><code>JsCallJava</code>类解析了<code>HostJsScope</code>类中所有的静态方法，将它们放到一个Map中，并且生成一段js代码</li>
<li>向WebView设置<code>InjectedChromeClient</code>，在<code>onProgressChanged</code>方法中将那段js代码注入到Html5页面中，这个过程通俗点讲就是，<strong>Native告诉Html 5页面，我开放了什么功能给你，你就来调用我</strong></li>
<li>这样js就可以调用Native提供的这些方法，那段js代码还会将js执行的方法转换成一段json字符串，通过js的prompt方法传到<code>onJsPrompt</code>方法中，<code>JsCallJava</code>调用<code>call(WebView view, String msg)</code>解析json字符串，包括要执行的<strong>方法名字</strong>，<strong>参数类型</strong>和<strong>方法参数</strong>，其中还会验证json中的方法参数类型和<code>HostJsScope</code>中同名方法参数类型是否一致等等。</li>
<li>最后，如果方法正确执行，<code>call</code>方法就返回一个json字符串code=200，否则就传code=500，这个信息会通过<code>prompt</code>方法的返回值传给js，这样Html 5 代码就能知道有没有正确执行了</li>
</ol>
<p>以上就是这个开源库的整个原理，我个人觉得非常适合用于Hybrid开发，这个解决方案中js可以收到Native的返回值，而且没有使用<code>addJavascriptInterface</code>方法，在低版本手机上也不会有安全问题，这个方法比Cordova的实现和配置简单</p>
<p>那么当我点击Html 5页面上的一个按钮，比如弹出对话框，这个过程的整体流程是怎么样的呢</p>
<h2 id="微信的解决方案？">微信的解决方案？</h2><p>什么？你问我微信是怎么解决的？我也反编译了微信的代码，想研究一下他们是解决的，其实我非常好奇微信的这种js 调用Native，并且又返回的调用方法</p>
<p>首先，我去微信的js sdk官网看了一下js sdk提供的功能，提供了各种强大的功能，各位可以自己去看一下。那么问题来了，微信是怎么做到js 调用Native并且能够成功返回的呢？</p>
<p>带着疑问我反编译了微信Android客户端，在assers/jsapi中看到了<code>wxjs.js</code>文件，我想这个就是微信js sdk的源码了吧。。。</p>
<p>我首先说一下，我不太懂js的代码， 我只能连蒙带猜的看微信的js代码，<code>如果有js大神对这方面也感兴趣，希望可以一起(jian)探(fei)讨(zao)</code></p>
<p>在<code>wxjs.js</code>中看到了一下代码，我猜微信就是用这个<code>__WeixinJSBridge</code>当时js和Native进行通信的数据结构吧？</p>
<pre><code>var __WeixinJSBridge = {
    // public
    invoke:_call,
    call:_call,
    on:_onfor3rd,
    env:_env,
    <span class="built_in">log</span>:_<span class="built_in">log</span>,
    // private
    // _<span class="built_in">test</span>_start:_<span class="built_in">test</span>_start,
    _fetchQueue: _fetchQueue,
    _handleMessageFromWeixin: _handleMessageFromWeixin,
    _hasInit: <span class="literal">false</span>,
    _<span class="built_in">continue</span>SetResult: _<span class="built_in">continue</span>SetResult
};
</code></pre><p>然后我又看到了下面的代码，我想应该是提供分享内容到朋友圈功能的吧</p>
<pre><code>// share timeline
_on<span class="list">(<span class="quoted">'menu</span><span class="keyword">:share</span><span class="keyword">:timeline</span>',function<span class="list">(<span class="keyword">argv</span>)</span>{
  _log<span class="list">(<span class="quoted">'share</span> timeline')</span><span class="comment">;</span>

  var data<span class="comment">;</span>
  if <span class="list">(<span class="keyword">typeof</span> argv.title === <span class="quoted">'string</span>')</span> {
    data = argv<span class="comment">;</span>
    _call<span class="list">(<span class="quoted">'shareTimeline</span>',data)</span><span class="comment">;</span>
  }else{
    data = {
        // <span class="string">"img_url"</span>: <span class="string">""</span>,
        // <span class="string">"img_width"</span>: <span class="string">""</span>,
        // <span class="string">"img_height"</span>: <span class="string">""</span>,
        <span class="string">"link"</span>: document.documentURI || _session_data.init_url,
        <span class="string">"desc"</span>: document.documentURI || _session_data.init_url,
        <span class="string">"title"</span>: document.title
    }<span class="comment">;</span>

    var shareFunc = function<span class="list">(<span class="keyword">_img</span>)</span>{          
      if <span class="list">(<span class="keyword">_img</span>)</span> {
          data[<span class="quoted">'img_url</span>'] = _img.src<span class="comment">;</span>
          data[<span class="quoted">'img_width</span>'] = _img.width<span class="comment">;</span>
          data[<span class="quoted">'img_height</span>'] = _img.height<span class="comment">;                        </span>
      }

      _call<span class="list">(<span class="quoted">'shareTimeline</span>',data)</span><span class="comment">;</span>
    }<span class="comment">;</span>

    getSharePreviewImage<span class="list">(<span class="keyword">shareFunc</span>)</span><span class="comment">;</span>
  }
})</span><span class="comment">;</span>
</code></pre><p>请注意最后这句：<code>_call(&#39;shareTimeline&#39;,data);</code>，在看看<code>__WeixinJSBridge</code>中的<code>call</code>属性，接着我找到了<code>_call</code>方法。</p>
<pre><code>function _call(func,<span class="keyword">params</span>,callback) {
    <span class="keyword">var</span> curFuncIdentifier = __WeixinJSBridge.call;
    <span class="keyword">if</span> (curFuncIdentifier !== _callIdentifier) {
        <span class="keyword">return</span>;
    }
    <span class="keyword">if</span> (!func || <span class="keyword">typeof</span> func !== <span class="string">'string'</span>) {
        <span class="keyword">return</span>;
    };
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">params</span> !== <span class="string">'object'</span>) {
        <span class="keyword">params</span> = {};
    };

    <span class="keyword">var</span> callbackID = (_callback_count++).toString();

    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) {
      _callback_map[callbackID] = callback;
    };

    <span class="keyword">var</span> msgObj = {<span class="string">'func'</span>:func,<span class="string">'params'</span>:<span class="keyword">params</span>};
    msgObj[_MESSAGE_TYPE] = <span class="string">'call'</span>;        
    msgObj[_CALLBACK_ID] = callbackID;

    _sendMessage(JSON.stringify(msgObj));
}
</code></pre><p>大致意思应该就是：就是将这个东西<code>_call(&#39;shareTimeline&#39;,data);</code>转换成一个json字符串吧，从这里看到微信的做法和上面那个开源库非常类似，简单并且安全。<code>_call</code>方法最后调用<code>_sendMessage</code>方法发送消息</p>
<pre><code><span class="comment">//将消息添加到发送队列，iframe的准备队列为weixin://dispatch_message/</span>
<span class="function"><span class="keyword">function</span> <span class="title">_sendMessage</span><span class="params">(message)</span> {</span>
    _sendMessageQueue.push<span class="params">(message)</span>;
    _readyMessageIframe.src = _CUSTOM_PROTOCOL_SCHEME + ':<span class="comment">//' + _QUEUE_HAS_MESSAGE;</span>

    <span class="comment">// var ifm = _WXJS('iframe#__WeixinJSBridgeIframe')[0];</span>
    <span class="comment">// if (!ifm) {</span>
    <span class="comment">//   ifm = _createQueueReadyIframe(document);</span>
    <span class="comment">// }</span>
    <span class="comment">// ifm.src = _CUSTOM_PROTOCOL_SCHEME + '://' + _QUEUE_HAS_MESSAGE;</span>
};
</code></pre><p>从上面代码可以看到微信的js sdk也是将js的方法调用换成一个类似<code>weixin://dispatch_message/</code>这样的url，上面说的json封装的数据。那么我猜测微信的做法是类似网易云音乐的拦截url吗？如果真的是这样的话，就非常不安全了，随便一个Html 5页面可以伪造一个类似：<code>weixin://dispatch_message/</code>这样的url来调用微信的功能了，不过好在微信对每个js调用都必须带上appid。</p>
<p>在反编译后的微信代码，我看到了下面代码：</p>
<p><img src="http://i1.tietuku.com/003b8cf9f3012d19.png" alt="image"></p>
<p>我想这写就是微信想Html 5开放的接口吧？不过对比了一下微信js sdk的官网，我看到好多App提供的功能在js sdk中并没有找到，这样也没有太大关系，以为微信只要升级js sdk就可以使用其他功能了，因为Native已经开放了嘛~</p>
<p>从上面<code>__WeixinJSBridge</code>可以看到有一个熟悉<code>_handleMessageFromWeixin</code>，这个就是js来处理Native的回调接口，我用这个字符串在微信代码中搜索，结果如下：</p>
<p><img src="http://i3.tietuku.com/e0b5b487f20e50ac.png" alt="image"></p>
<p>因此，我大致猜测，微信中的js调Native功能是用拦截url的方式，而Native回调的话是使用<code>evaluateJavascript</code>方法</p>
<p>我也在js sdk中找到了相应的函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">_handleMessageFromWeixin</span>(<span class="params">message</span>) </span>{
    <span class="keyword">var</span> curFuncIdentifier = __WeixinJSBridge._handleMessageFromWeixin;
    <span class="keyword">if</span> (curFuncIdentifier !== _handleMessageIdentifier) {
        <span class="keyword">return</span> <span class="string">'{}'</span>;
    }

    <span class="keyword">var</span> ret;
    <span class="keyword">var</span> msgWrap
    <span class="keyword">if</span> (_isUseMd5 === <span class="string">'yes'</span>) {
      <span class="keyword">var</span> realMessage = message[_JSON_MESSAGE];
      <span class="keyword">var</span> shaStr = message[_SHA_KEY];
      <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>;
      arr[<span class="number">0</span>] = <span class="built_in">JSON</span>.stringify(realMessage);
      arr[<span class="number">1</span>] = _xxyy;
      <span class="keyword">var</span> str = arr.join(<span class="string">""</span>);
      <span class="keyword">var</span> msgSha = <span class="string">''</span>;
        <span class="keyword">var</span> shaObj = CryptoJS.SHA1(str);
        msgSha = shaObj.toString();
        <span class="keyword">if</span> (msgSha !== shaStr) {
            _log(<span class="string">'_handleMessageFromWeixin , shaStr : '</span> + shaStr + <span class="string">' , str : '</span> + str + <span class="string">' , msgSha : '</span> + msgSha);
            <span class="keyword">return</span> <span class="string">'{}'</span>;

        }
        msgWrap = realMessage;
    }
    <span class="comment">//省略很多代码</span>
</code></pre><p>微信的做法应该说非常基础，使用了原生的功能，但是安全，由于微信客户端对每一个js调用都有验证（appid），因此这也增加了一定的安全性</p>
<p>以上说的都是建立在我的分析正确的情况下。</p>
<h1 id="一些个人的想法">一些个人的想法</h1><p>现在各种新的技术也在想办法解决Native开发的效率问题，想用技术来解决一套代码运行在Android和iOS客户端，我相信随着技术的发展这些问题都会解决。我也好期待Facebook即将推出的<a href="http://www.reactnativeandroid.com/" target="_blank" rel="external">React Native Android</a></p>
<h2 id="Hybrid开发适用于哪些功能">Hybrid开发适用于哪些功能</h2><p>本文讲的Hybrid开发就是Native客户端中嵌入了Html App的功能，这方面微信应该是做的最好的，由于Html 5的效率以及耗电问题，我个人觉得用户是不能满足Web App的体验的，Hybrid App也只适用于某些场景。一些基础的功能，比如调用手机的摄像头，获取地理位置，登录注册功能等等，做成Native的功能，让Html 5来调用更好，这样的体验也更好。</p>
<p>如果你把一个登录和注册功能也做成Html 5，在弱网络环境下，这个体验应该会非常的差，或许你等半天还没加载出页面。你可能会说，我可以预先加载Html 5的代码，打开App时直接加载，那么我说你在给自己找麻烦，如果要这样的话，Native开发或许更快一点。</p>
<p>那么什么情况适合Html 5开发呢？像一些活动页面，比如秒杀、团购等适合做Html 5，因为这些页面可能涉及的非常炫而且复杂，Html 5开发或许会简单点，关键是这些页面时效性短，更新更快，因为一个活动说不定就一周时间，下周换活动，如果这样的话，你还做Native是肯定不行的</p>
<h1 id="总结-1">总结</h1><p>有那么一句<a href="http://mindhacks.cn/2009/01/16/hammers-and-nails/" target="_blank" rel="external">古老的箴言</a>：</p>
<blockquote>
<p>如果你手里有一把锤子，所有东西看上去都想钉子</p>
</blockquote>
<p>千万不要以为Hybrid开发能够夸平台运行，就使用Hybrid开发任何功能。其实Facebook早期也是这么想的，后来就是因为WebView渲染效率底下，把整个应用改为Native开发，请看<a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-rebuilding-facebook-for-android/10151189598933920" target="_blank" rel="external">这里</a></p>
<p>引用Facebook的一段话：</p>
<blockquote>
<p>Today, we’re releasing a new version of Facebook for Android that’s been rebuilt in native code to improve speed and performance. To support the unique complexity of Facebook stories across devices, we’re moving from a hybrid native/webview to pure native code, allowing us to optimize the Facebook experience for faster loading, new user interfaces, disk cache, and so on.</p>
</blockquote>
<p>本文主要还是从技术上谈谈Hybrid开发中js和Native交互的技术实现原理。抛砖引玉，写的估计也有很多错的，希望技术大牛指出。</p>
<p>最后，我觉得那个开源的库是一个非常不错的解决方案，解决办法巧妙、简单而且安全。当时我debug了半天弄明白其中的原理后，我一拍大腿，这办法真好啊！！网易云音乐的解决办法适用于它的场景，不需要回调，Native只需要处理相应的信息，然后来实现页面跳转、播放音乐、播放MV等功能，这个方法也简单好用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>混合开发的App（Hybrid App）就是在一个App中内嵌一个轻量级的浏览器，一部分原生的功能改为Html 5来开发，这部分功能不仅能够在不升级App的情况下动态更新，而且可以在Android或iOS的App上同时运行，让用户的体验更好又可以节省开发的资源。</p>
<p>下面来谈谈Hybrid App开发中的技术问题。iOS方面的我不太了解，我就主要谈谈Android开发中的，其中可能会有很多说错的，请大家轻喷</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Android开发中Java对象序列化的一次测试]]></title>
    <link href="http://bxbxbai.gitcafe.io/2015/05/05/a-serializable-test/"/>
    <id>http://bxbxbai.gitcafe.io/2015/05/05/a-serializable-test/</id>
    <published>2015-05-05T11:29:24.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>Android开发过程中会遇到很多情况，需要将一个Java序列化，比如序列化一个对象来保存当前一些信息，等下次App启动后再还原。</p>
<p>对象序列化可以有好多种方法，一般最简单的就是实现<code>Serializable</code>接口，通过<code>ObjectOutputStream</code>写到SD卡中；还有可以将Java对象序列化到数据库中；还可以将Java对象转成一个字符串，把这个字符串写到SD卡中，反序列化时读取这个字符串，并且转成一个Java对象。</p>
<p>如果只保存一个Java对象，你应该不会把它写到数据库中的，一般会使用另外两种方法，但是那种方法好呢？</p>
<a id="more"></a>
<h2 id="方法0：实现Serializable接口">方法0：实现Serializable接口</h2><p>写上两段代码</p>
<pre><code><span class="comment">//将Object写入SD卡</span>
<span class="keyword">private</span> <span class="keyword">void</span> writeObject(Object result) {
    ObjectOutputStream oos = <span class="keyword">null</span>;
    FileOutputStream fileOutputStream = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(Config.getCachePath() + <span class="string">"bxbxbai"</span>);
        fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">file</span>);
        oos = <span class="keyword">new</span> ObjectOutputStream(fileOutputStream);
        oos.writeObject(result);
    } <span class="keyword">catch</span> (Exception e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        <span class="keyword">try</span> {
            fileOutputStream.close();
            oos.close();
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}

<span class="comment">//读取Object</span>
<span class="keyword">private</span> Object readObject() {
    Object object = <span class="keyword">null</span>;
    <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(Config.getCachePath() + <span class="string">"bxbxbai"</span>);
    <span class="keyword">if</span> (<span class="keyword">file</span>.isFile()) {
        ObjectInputStream ois = <span class="keyword">null</span>;
        FileInputStream fileInputStream = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">file</span>);
            ois = <span class="keyword">new</span> ObjectInputStream(fileInputStream);
            object = ois.readObject();
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="keyword">finally</span> {
            <span class="keyword">try</span> {
                fileInputStream.close();
                ois.close();
            } <span class="keyword">catch</span> (Exception e) {
                e.printStackTrace();
            }
        }
        <span class="keyword">return</span> object;
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><p>##方法1：将对象转换成String序列化</p>
<pre><code><span class="comment">//先用Gson将对象转换成String，然后把String写入SD卡</span>
<span class="keyword">private</span> <span class="keyword">void</span> writeObjectString(Object result) {
    String s = <span class="keyword">new</span> Gson().toJson(result);
    FileOutputStream fileOutputStream = <span class="keyword">null</span>;
    <span class="keyword">try</span> {
        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(Config.getCachePath() + <span class="string">"bxbxbai_string"</span>);
        fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">file</span>);
        BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(fileOutputStream));
        writer.<span class="keyword">write</span>(s);
        writer.flush();
        writer.close();
    } <span class="keyword">catch</span> (Exception e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        <span class="keyword">try</span> {
            fileOutputStream.close();
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}

<span class="comment">//先读取String，然后转成Java对象</span>
<span class="keyword">private</span> Object readObjectString() {
    <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(Config.getCachePath() + <span class="string">"bxbxbai_string"</span>);
    <span class="keyword">if</span> (<span class="keyword">file</span>.isFile()) {
        <span class="keyword">try</span> {
            Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">file</span>);
            StringBuilder json = <span class="keyword">new</span> StringBuilder();
            <span class="keyword">while</span> (scanner.hasNext()) {
                json.<span class="keyword">append</span>(scanner.nextLine());
            }
            scanner.close();
            <span class="keyword">return</span> <span class="keyword">new</span> Gson.fromJson(json.toString(), SerializeStringResult.<span class="keyword">class</span>);
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</code></pre><p>##测试</p>
<p>基本的功能代码已经都贴了，下面是测试代码：</p>
<pre><code>private void test<span class="params">()</span> {
    try {
        <span class="comment">//省略创建object代码，result0 和result1 完全一样</span>
        StopWatch.begin<span class="params">(<span class="string">"writeObject"</span>)</span>;
        writeObject<span class="params">(result0)</span>;
        StopWatch.end<span class="params">(<span class="string">"writeObject"</span>)</span>;

        StopWatch.begin<span class="params">(<span class="string">"readObject"</span>)</span>;
        Object o1 = readObject<span class="params">()</span>;
        StopWatch.end<span class="params">(<span class="string">"readObject"</span>)</span>;

        <span class="comment">//写String</span>
        StopWatch.begin<span class="params">(<span class="string">"writeObjectString"</span>)</span>;
        writeObjectString<span class="params">(result1)</span>;
        StopWatch.end<span class="params">(<span class="string">"writeObjectString"</span>)</span>;

        StopWatch.begin<span class="params">(<span class="string">"readObjectString"</span>)</span>;
        Object o2 = readObjectString<span class="params">()</span>;
        StopWatch.end<span class="params">(<span class="string">"readObjectString"</span>)</span>;
    } catch <span class="params">(Exception e)</span> {
        e.printStackTrace<span class="params">()</span>;
    }
}
</code></pre><p>测试数据是地址：<a href="http://bxbxbai.gitcafe.io/img/data.txt">地址</a>，测试手机使用LG-D858</p>
<p>##测试结果(单位ms)</p>
<table>
<thead>
<tr>
<th>.</th>
<th style="text-align:center"><strong>writeObject</strong></th>
<th style="text-align:right"><strong>readObject</strong></th>
<th style="text-align:right">writeObjectString</th>
<th style="text-align:right"><strong>readObjectString</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td style="text-align:center">324</td>
<td style="text-align:right">111</td>
<td style="text-align:right">44</td>
<td style="text-align:right">66</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td style="text-align:center">285</td>
<td style="text-align:right">104</td>
<td style="text-align:right">29</td>
<td style="text-align:right">60</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td style="text-align:center">286</td>
<td style="text-align:right">95</td>
<td style="text-align:right">30</td>
<td style="text-align:right">61</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td style="text-align:center">271</td>
<td style="text-align:right">91</td>
<td style="text-align:right">30</td>
<td style="text-align:right">60</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td style="text-align:center">288</td>
<td style="text-align:right">94</td>
<td style="text-align:right">29</td>
<td style="text-align:right">58</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td style="text-align:center">260</td>
<td style="text-align:right">91</td>
<td style="text-align:right">28</td>
<td style="text-align:right">63</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td style="text-align:center">273</td>
<td style="text-align:right">93</td>
<td style="text-align:right">27</td>
<td style="text-align:right">60</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td style="text-align:center">267</td>
<td style="text-align:right">92</td>
<td style="text-align:right">27</td>
<td style="text-align:right">61</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td style="text-align:center">265</td>
<td style="text-align:right">172</td>
<td style="text-align:right">27</td>
<td style="text-align:right">59</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td style="text-align:center">299</td>
<td style="text-align:right">97</td>
<td style="text-align:right">29</td>
<td style="text-align:right">64</td>
</tr>
<tr>
<td><strong>Average</strong></td>
<td style="text-align:center"><strong>282</strong></td>
<td style="text-align:right"><strong>104</strong></td>
<td style="text-align:right"><strong>30</strong></td>
<td style="text-align:right"><strong>61</strong></td>
</tr>
</tbody>
</table>
<p>一共测试了10次，平均结果如下：</p>
<ul>
<li>Serializable写：282ms</li>
<li>Serializable读：104ms</li>
<li>转String写：30ms</li>
<li>转String读：61ms</li>
</ul>
<p>也就是说将Java对象转成String再进行序列化以及反序列化可以大大减少时间。</p>
<blockquote>
<p>Once upon a time, this used the standard Java Object{Input,Output}Stream, but the default implementation relies heavily on reflection (even for standard types) and generates a ton of garbage.</p>
</blockquote>
<p>上面这段话是我几个月前我看<a href="http://bxbxbai.gitcafe.io/2014/12/24/read-volley-source-code/">Volley源码</a>的时候看到的，在<code>DiskBasedCache</code>类中，大致的意思就是之前Volley也是用Java对象的序列化来缓存HTTP 头信息的，后来发现<code>Object{Input,Output}Stream</code>序列化严重依赖反射机制，<strong>会在序列化过程中产生大量的临时对象，从而更加频繁的触发GC</strong>，后来Google的工程师自己写了一个简单的序列化和反序列化方法</p>
<p>##总结</p>
<p>从测试结果中可以看到，将Java对象转换成String，然后在把String序列化可以节省大量的时间。不仅如此，<code>Object{Input,Output}Stream</code>序列化方法严重依赖Java反射机制，在序列化过程中会产生大量的临时对象，会更加频繁的触发GC操作</p>
<p>所以，我觉得还是把Java对象转成String再序列化吧，可以提升不少性能呢 ：）</p>
<h2 id="2015-05-07_更新">2015.05.07 更新</h2><p>我这个是测试这两个序列化方法的性能。注意一下，Gson库将一个Java对象转成字符串也是使用Java反射的，如果某些场景需要更高的性能，那么需要自己写序列化方法。</p>
<p>比如，参考<code>Parcelable</code>接口，我们自己写代码，将对象转换成字符串（而不是依赖Gson库来转成字符串）序列化，以及相应的反序列化。或许你还想到了其他更好的方法，希望你能和我分享讨论~ ：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android开发过程中会遇到很多情况，需要将一个Java序列化，比如序列化一个对象来保存当前一些信息，等下次App启动后再还原。</p>
<p>对象序列化可以有好多种方法，一般最简单的就是实现<code>Serializable</code>接口，通过<code>ObjectOutputStream</code>写到SD卡中；还有可以将Java对象序列化到数据库中；还可以将Java对象转成一个字符串，把这个字符串写到SD卡中，反序列化时读取这个字符串，并且转成一个Java对象。</p>
<p>如果只保存一个Java对象，你应该不会把它写到数据库中的，一般会使用另外两种方法，但是那种方法好呢？</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可以滑动切歌的播放控制条（模仿QQ音乐）]]></title>
    <link href="http://bxbxbai.gitcafe.io/2015/04/07/swipe-playbar/"/>
    <id>http://bxbxbai.gitcafe.io/2015/04/07/swipe-playbar/</id>
    <published>2015-04-07T11:59:09.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>看了QQ音乐Android版有这个功能，觉得挺好玩的，就模仿它做了一个demo，可以滑动切歌（转换的gif严重失真，只能截图了 -.-）</p>
<p>项目地址：<a href="https://github.com/bxbxbai/SwipePlaybarDemo" target="_blank" rel="external">https://github.com/bxbxbai/SwipePlaybarDemo</a></p>
<p>下载地址：<a href="http://vdisk.weibo.com/s/GGofvp4_QVU/1428410542" target="_blank" rel="external">http://vdisk.weibo.com/s/GGofvp4_QVU/1428410542</a></p>
<p>底部播放条的歌曲信息可以滑动切换，并且专辑图会转动</p>
<a id="more"></a>
<p>##看看截图<br>这个是4个播放条的截图：<br><img src="http://i2.tietuku.com/de77e5c2f25e89f1.png" alt="playbar"> </p>
<p>##实现</p>
<p>这个功能就是使用<code>ViewPager</code>这个组件来实现，然后最主要的就是为这个<code>ViewPager</code>写一个<code>PagerAapter</code>。这个<code>PagerAdapter</code>写起来也容易，但是我在这个类里做了一些优化。</p>
<p>这个<code>PagerAdapter</code>的全部代码就在下面：</p>
<pre><code><span class="comment">/**
  * PlayBar ViewPager Adapter 
  * 
  * <span class="doctag">@author</span> bxbxbai
*/</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayCtrlBarPagerAdapter</span> <span class="keyword">extends</span> <span class="title">PagerAdapter</span> </span>{

  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_SONGS = <span class="number">10</span>;
  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ANIMATOR_DURATION = <span class="number">1000</span> * <span class="number">10</span>;

  <span class="keyword">private</span> LayoutInflater mInflater;

  <span class="keyword">private</span> Queue&lt;View&gt; mReusableViews;


  <span class="function"><span class="keyword">public</span> <span class="title">PlayCtrlBarPagerAdapter</span><span class="params">(Context context)</span> </span>{
    mInflater = LayoutInflater.from(context);
    mReusableViews = <span class="keyword">new</span> ArrayDeque&lt;&gt;(NUM_SONGS);
  }

  <span class="annotation">@Override</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> NUM_SONGS;
  }

  <span class="annotation">@Override</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewFromObject</span><span class="params">(View view, Object object)</span> </span>{
    <span class="keyword">return</span> view == object;
  }

  <span class="annotation">@Override</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>{
    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> View) {
        container.removeView((View) object);
        mReusableViews.add((View) object);
    }
  }

  <span class="annotation">@Override</span>
  <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>{
    View v = mReusableViews.poll();
    <span class="keyword">if</span> (v == <span class="keyword">null</span>) {
        v = mInflater.inflate(R.layout.layout_music, container, <span class="keyword">false</span>);
        setAnimator(v);
    }
    bindData(v, position);
    container.addView(v);
    <span class="keyword">return</span> v;
 }

  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindData</span><span class="params">(View v, <span class="keyword">int</span> position)</span> </span>{
    TextView songName = ButterKnife.findById(v, R.id.tv_song_name);
    songName.setText(<span class="string">"Try - "</span> + position);

    ImageView artistImage = ButterKnife.findById(v, R.id.iv_artist_cover);
    <span class="keyword">if</span> (position % <span class="number">2</span> == <span class="number">1</span>) {
        artistImage.setImageResource(R.drawable.adele);
    } <span class="keyword">else</span> {
        artistImage.setImageResource(R.drawable.bxbxbai);
    }
 }

  <span class="annotation">@Override</span>
  <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPageWidth</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
    <span class="keyword">return</span> <span class="number">1.0f</span>;
  }

  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAnimator</span><span class="params">(View view)</span> </span>{
    ObjectAnimator animator = ObjectAnimator.ofFloat(view.findViewById(R.id.iv_artist_cover), <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">360f</span>);
    animator.setRepeatCount(Integer.MAX_VALUE);
    animator.setDuration(ANIMATOR_DURATION);
    animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());

    view.setTag(R.id.tag_animator, animator);
  }
}
</code></pre><p>##优化PagerAdapter</p>
<p><code>PagerAdapter</code>和Android中<code>ListView</code>的<code>Adapter</code>类似，但是一个主要的不同就是<code>PagerAdapter</code>提供了一个回调方法来让我们处理销毁的Item。</p>
<p>一个<code>ViewPager</code>默认的<code>offScreenPageLimit</code>为1，也就是说当一个<code>ViewPager</code>当前显示页为<code>2</code>，那么<code>PagerAdapter</code>中还存在左右两个Pager，也就是<code>1</code>和<code>3</code>。此时，如果我们将<code>ViewPager</code>滑向<code>3</code>，那么<code>PagerAdapter</code>首先会通过<code>public void destroyItem(ViewGroup container, int position, Object object)</code>方法销毁第<code>1</code>个Item，然后通过<code>public Object instantiateItem(ViewGroup container, int position)</code>生成第<code>4</code>的Item，并且显示当前的Item（为<code>3</code>）。此时，<code>PagerAdapter</code>中存在的Item为<code>2</code>和<code>4</code></p>
<p>从这个思路出发，我也就可以在<code>destroyItem</code>方法中保存这个object，然后在<code>instantiateItem</code>中使用。</p>
<p>###看上面的代码</p>
<p>我写了一个<code>Queue&lt;View&gt; mReusableViews;</code>在<code>destroyItem</code>中保存被销毁的Item，然后在<code>instantiateItem</code>方法中首先去<code>mReusableViews</code>中获取。</p>
<p>如果存在可以重用的Item，那么就不用inflate一个View了，直接绑定数据就可以。否则就创建一个新的View来使用</p>
<p>在实验过程中发现，如果<code>ViewPager</code>的<code>offScreenPageLimit</code>为1，那么只需要创建3个View，其他的View都可以重复使用，这样就可以提升性能了</p>
<p>##如何让ImageView转起来</p>
<p>在<code>View</code>绑定数据的时候通过一个工具方法，为每个<code>View</code>都设置一个<code>ObjectAnimator</code>属性动画。然后我为这个<code>ViewPager</code>专门写了一个<code>ViewPager.PageTransformer</code>类</p>
<p>其实代码也很简单，就是当某一个page完全显示的时候（position为0），开始动画，否则停止动画</p>
<p>如果你需要在<code>ViewPager</code>上添加一些其他特效，那么可以通过<code>addTransformer</code>方法添加PageTransformer</p>
<pre><code><span class="comment">/**
 * 播放条的PagerTransformer
 *
 * @author bxbxbai
 */</span>
public class PlaybarPagerTransformer implements ViewPager.PageTransformer {

  private List&lt;ViewPager.PageTransformer&gt; mTransformers = new ArrayList&lt;&gt;<span class="params">()</span>;

  @Override
  public void transformPage<span class="params">(View page, float position)</span> {
    <span class="keyword">for</span> <span class="params">(ViewPager.PageTransformer transformer : mTransformers)</span> {
        transformer.transformPage<span class="params">(page, position)</span>;
    }

    <span class="comment">//处理图片旋转</span>

    StopWatch.<span class="built_in">log</span><span class="params">(<span class="string">"page: "</span> + page + <span class="string">", pos: "</span> + position)</span>;

    <span class="keyword">if</span> <span class="params">(position == <span class="number">0</span>)</span> {
        ObjectAnimator animator = <span class="params">(ObjectAnimator)</span> page.getTag<span class="params">(R.id.tag_animator)</span>;
        <span class="keyword">if</span> <span class="params">(animator != null)</span> {
            animator.start<span class="params">()</span>;
        }
    } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(position == -<span class="number">1</span> || position == -<span class="number">2</span> || position == <span class="number">1</span>)</span> {
        ObjectAnimator animator = <span class="params">(ObjectAnimator)</span> page.getTag<span class="params">(R.id.tag_animator)</span>;
        <span class="keyword">if</span> <span class="params">(animator != null)</span> {
            animator.end<span class="params">()</span>;
        }
    }
  }


  public void addTransformer<span class="params">(ViewPager.PageTransformer transformer)</span> {
    <span class="keyword">if</span> <span class="params">(transformer != null)</span> {
        mTransformers.add<span class="params">(transformer)</span>;
    }
  }
}
</code></pre><h2 id="Dependency_-_依赖">Dependency - 依赖</h2><ul>
<li>Java Development Kit (JDK) 7 +</li>
<li>com.android.tools.build:gradle:1.0.0</li>
<li>Android SDK<ul>
<li>Android SDK Build-tools 21.1.2</li>
</ul>
</li>
</ul>
<h2 id="Build_-_构建">Build - 构建</h2><pre><code>git clone <span class="string">https:</span><span class="comment">//github.com/bxbxbai/SwipePlaybarDemo.git</span>
</code></pre><p>用最新的IntelliJ IDE导入工程（Import Project），然后等待IDE下载gradle和依赖包即可</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看了QQ音乐Android版有这个功能，觉得挺好玩的，就模仿它做了一个demo，可以滑动切歌（转换的gif严重失真，只能截图了 -.-）</p>
<p>项目地址：<a href="https://github.com/bxbxbai/SwipePlaybarDemo">https://github.com/bxbxbai/SwipePlaybarDemo</a></p>
<p>下载地址：<a href="http://vdisk.weibo.com/s/GGofvp4_QVU/1428410542">http://vdisk.weibo.com/s/GGofvp4_QVU/1428410542</a></p>
<p>底部播放条的歌曲信息可以滑动切换，并且专辑图会转动</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[知乎专栏App]]></title>
    <link href="http://bxbxbai.gitcafe.io/2015/03/26/zhuanlan/"/>
    <id>http://bxbxbai.gitcafe.io/2015/03/26/zhuanlan/</id>
    <published>2015-03-26T11:55:31.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>最近一直在利用空余时间开发一个完整的App，名字就叫“专栏”。开发这个App的目的主要是为了练练手，熟悉开发一个完整App的流程。就像造房子，亲手打地基，搬砖头，垒砖头，还自己装修（虽然装修的不好看）</p>
<p>项目地址：<a href="https://github.com/bxbxbai/ZhuanLan" target="_blank" rel="external">https://github.com/bxbxbai/ZhuanLan</a></p>
<a id="more"></a>
<p>##1.1版本<br>现在App在Android 4.4系统上支持沉浸式状态栏了，个人感觉更加好看了，增加了抽屉菜单功能（部分功能还未完成）。</p>
<p>最新添加了“最近一周文章”功能，这功能会显示所有内置专栏作者最近一周的文章列表，并且所有的文章会按时间排序。还添加了“查看原网页”功能</p>
<p>##看截图：</p>
<p><img src="http://i2.tietuku.com/0753db9e1804f6b3.png" alt="闪屏"></p>
<p><img src="http://i2.tietuku.com/2970239f71296398.png" alt="专栏列表"></p>
<p><img src="http://i2.tietuku.com/6fa9fc0c9c2de428.png" alt="文章列表"></p>
<p><img src="http://i2.tietuku.com/ace4ca3200ad7a09.png" alt="文章内容"></p>
<p><img src="http://i2.tietuku.com/da044bdfabfe3e4f.png" alt="网页版"></p>
<h2 id="Dependency_-_依赖">Dependency - 依赖</h2><ul>
<li>Java Development Kit (JDK) 7 +</li>
<li>com.android.tools.build:gradle:1.0.0</li>
<li>Android SDK 21</li>
<li>Android SDK Build-tools 21.1.2</li>
</ul>
<h2 id="Build_-_构建">Build - 构建</h2><pre><code>git clone <span class="string">https:</span><span class="comment">//github.com/bxbxbai/ZhuanLan.git</span>
</code></pre><p>用最新的IntelliJ IDE导入工程（Import Project），然后等待IDE下载gradle和依赖包即可。</p>
<p>##用到的开源库</p>
<ul>
<li>Volley</li>
<li>Gson</li>
<li>Material-Menu</li>
<li>systembartint</li>
</ul>
<p>##放一个不要脸的图片 -。-</p>
<p>如果你觉得我做的东西对你有帮助，或者你认可我做的东西，就不妨请我喝杯咖啡吧~</p>
<p><img src="http://i2.tietuku.com/e991cad27820649d.jpg" alt="image"></p>
<p>（支付宝扫一扫）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近一直在利用空余时间开发一个完整的App，名字就叫“专栏”。开发这个App的目的主要是为了练练手，熟悉开发一个完整App的流程。就像造房子，亲手打地基，搬砖头，垒砖头，还自己装修（虽然装修的不好看）</p>
<p>项目地址：<a href="https://github.com/bxbxbai/ZhuanLan">https://github.com/bxbxbai/ZhuanLan</a></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开源" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开发笔记0]]></title>
    <link href="http://bxbxbai.gitcafe.io/2015/02/08/android-develop-notes-0/"/>
    <id>http://bxbxbai.gitcafe.io/2015/02/08/android-develop-notes-0/</id>
    <published>2015-02-08T03:13:56.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>记录一些好用的开发技巧</p>
<a id="more"></a>
<p>#0. 自定义一个View</p>
<p>现在的音乐播放器，比如天天动听或网易云音乐中都会将推荐页面中的内容进行分块，比如热门推荐、个性化推荐、最新音乐等等。每个区块前面都会有一个标题，如下图：</p>
<p><img src="http://i2.tietuku.com/4ee54aa7c8091807.png" alt="云音乐"></p>
<p><img src="http://i2.tietuku.com/c9eee15f9b35fb2c.png" alt="虾米"></p>
<p>可能很多人还在重用布局文件（layout文件）来做这些功能，但是如果你现在又需要在另一个（或多个）页面中使用这个标题，那么你就必须把标题的布局文件include进来，然后在代码里面<code>findViewById</code>来获取标题，还要设置标题<code>TextView</code>和标题前面小圆圈的主题什么的。<strong>这样你需要在每个使用这个标题的页面中都重复写这些代码</strong></p>
<p><strong>这样太麻烦了，你可以直接把它写成一个View，然后在布局文件中直接使用这个View</strong></p>
<pre><code><span class="comment">/**
 * 
 * <span class="doctag">@author</span> bxbxbai
 * <span class="doctag">@version</span> 1.0.0
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndicatorView</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>{

    TextView mTitle;

    <span class="function"><span class="keyword">public</span> <span class="title">IndicatorView</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">super</span>(context);
        init();
    }

    <span class="function"><span class="keyword">public</span> <span class="title">IndicatorView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{
        <span class="keyword">super</span>(context, attrs);
        init();
    }

    <span class="function"><span class="keyword">public</span> <span class="title">IndicatorView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>{
        <span class="keyword">super</span>(context, attrs, defStyleAttr);
        init();
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{
        View view = View.inflate(getContext(), R.layout.find_song_title_bar, <span class="keyword">this</span>);
        mTitle = (TextView) view.findViewById(R.id.id_text_title);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>{
        mTitle.setText(title);
    }
}
</code></pre><p>#1. 正方形的Layout<br>有很多情况会出现正方形的View，如下图：<br><img src="http://i3.tietuku.com/5664961aea30a6e4.png" alt="Square Post"></p>
<p>这样的布局一般会是最外面一个<code>LinearLayout</code>，包含一个<code>RelativeLayout</code>和一个<code>TextView</code>，这个<code>RelativeLayout</code>中包含了一个<code>ImageView</code>和两个<code>TextView</code>。如果把<code>ImageView</code>的<code>layout_height</code>设置成<code>wrap_content</code>，这样肯定会有问题，有的时候图片不是正方形的，就会有各种奇形怪状。</p>
<p>你也可以在加载图片的时候将Bitmap的高剪成和宽一致，但是这样太麻烦了。你也可以写一个<code>SqaureImageView</code>，但是我觉得这样的重用性不好。</p>
<p>其实，最好的方式还是将这个<code>RelativeLayout</code>换成<code>SquareLayout</code>，这是一个正方形的<code>RelativeLayout</code>。然后将<code>ImageView</code>的<code>layout_height</code>和<code>layout_width</code>设置成<code>match_parent</code>就可以了，图片自动设置为正方形，再按照需求设置<code>ImageView</code>的<code>scaleType</code></p>
<p>代码很少，如下：</p>
<pre><code><span class="comment">/**
 * Created by baia on 14/10/27.
 * <span class="doctag">@author</span> bxbxbai
 * <span class="doctag">@version</span> 1.0.0
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareLayout</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="title">SquareLayout</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">super</span>(context);
    }

    <span class="function"><span class="keyword">public</span> <span class="title">SquareLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{
        <span class="keyword">super</span>(context, attrs);
    }

    <span class="function"><span class="keyword">public</span> <span class="title">SquareLayout</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>{
        <span class="keyword">super</span>(context, attrs, defStyle);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{
        setMeasuredDimension(getDefaultSize(<span class="number">0</span>, widthMeasureSpec), getDefaultSize(<span class="number">0</span>, heightMeasureSpec));

        <span class="comment">//children are just made to fill our space</span>
        <span class="keyword">int</span> childWithSize = getMeasuredWidth();

        <span class="comment">//height is set to be same as width</span>
        heightMeasureSpec = widthMeasureSpec =
                MeasureSpec.makeMeasureSpec(childWithSize, MeasureSpec.EXACTLY);

        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre><p>#2. LinearLayout 的divider<br>先来看一张图：<br><img src="http://i3.tietuku.com/54a6e2b531d34aca.png" alt="LinearLayout 的divider"></p>
<p>如果要写上面图片中的布局，整体的布局肯定是两个<code>LinearLayout</code>，然后设置margin值让各个子View之间留出空隙。如果你设置了button_2隐藏了，然后你就看到了：</p>
<p><img src="http://i3.tietuku.com/85e99608e72b54e0.png" alt="此处输入图片的描述"></p>
<p><strong>图片中button_1右边留出了一个margin值</strong></p>
<p>如果你使用<code>LinearLayout</code>的<code>android:divider</code>属性就会极大的方便你的代码。<code>android:divider</code>的值是一个<code>drawable</code>，你可以定义一个如下drawable文件</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">shape</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/ 
    android:shape="</span><span class="value">rectangle"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">size</span>
        <span class="attribute">android:width</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:height</span>=<span class="value">"10dp"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">solid</span> <span class="attribute">android:color</span>=<span class="value">"@android:color/transparent"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">shape</span>&gt;</span>
</code></pre><p>其中，下面3个按钮的布局文件为：</p>
<pre><code>&lt;LinearLayout
    android:<span class="property">id</span>=<span class="string">"@+id/buttons_container"</span>
    android:layout_width=<span class="string">"match_parent"</span>
    android:divider=<span class="string">"@drawable/drawable_divider"</span>
    android:showDividers=<span class="string">"middle"</span>
    android:layout_height=<span class="string">"wrap_content"</span>
    android:orientation=<span class="string">"horizontal"</span>&gt;

    &lt;Button
        android:<span class="property">id</span>=<span class="string">"@+id/btn_0"</span>
        style=<span class="string">"@style/ButtonStyle"</span>
        android:background=<span class="string">"@android:color/holo_purple"</span>
        android:<span class="type">text</span>=<span class="string">"button_0"</span> /&gt;

    &lt;Button
        android:<span class="property">id</span>=<span class="string">"@+id/btn_1"</span>
        style=<span class="string">"@style/ButtonStyle"</span>
        android:background=<span class="string">"@android:color/darker_gray"</span>
        android:<span class="type">text</span>=<span class="string">"button_1"</span> /&gt;

    &lt;Button
        android:<span class="property">id</span>=<span class="string">"@+id/btn_3"</span>
        style=<span class="string">"@style/ButtonStyle"</span>
        android:background=<span class="string">"@android:color/holo_blue_dark"</span>
        android:<span class="type">text</span>=<span class="string">"button_2"</span> /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>比较重要的两句代码就是：</p>
<pre><code><span class="label">android:</span>divider=<span class="string">"@drawable/drawable_divider"</span>
<span class="label">android:</span>showDividers=<span class="string">"middle"</span>
</code></pre><p>这个<code>@drawable/drawable_divider</code>就是上面写的drawable文件，<code>showDividers</code>的值可以选择<code>beginning</code>, <code>middle</code>, <code>end</code>, <code>none</code>，什么意思一看就明白。</p>
<p><strong><code>LinearLayout</code>的<code>android:divider</code>是一个非常好用而且强大的功能噢～</strong></p>
<p>#3. 更加方便的启动Fragment或Activity</p>
<p>启动Activity的一个非常普遍的方法就是</p>
<pre><code><span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>(MainActivity.this, AlbumActivity.<span class="keyword">class</span>);
<span class="type">intent</span>.putExtra(ALBUM_ID, 00L);
startActivity(<span class="type">intent</span>);
</code></pre><p>如果app中有很多地方会启动<code>AlbumActivity</code>，那么这样的话你就需要在很多地方重复上面的代码，这不是在<strong>Repeat Yourself</strong>了吗。不光如此，如果一个Activity需要很多值，那么你就需要一个一个的设置，非常麻烦。</p>
<p>换个思路，你可以这样写：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">AlbumActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> {</span>
    <span class="comment">//....</span>

    <span class="comment">/**
     * launch activity
     * @param context Context
     * @param albumId id
    */</span>
    public static void launch(<span class="type">Context</span> context, long albumId) {
        <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(context, <span class="type">AlbumActivity</span>.<span class="keyword">class</span>);
        intent.putExtra(<span class="type">ALBUM_ID</span>, albumId);
        context.startActivity(intent);
    }

    <span class="comment">//...</span>
}
</code></pre><p>然后你就可以直接这样启动<code>AlbumActivity</code>：</p>
<pre><code>AlbumActivity.launch(MainActivity.<span class="keyword">this</span>, <span class="number">100L</span>);
</code></pre><p>其实启动Fragment也可以使用这样的方法，超级方便。</p>
<p><strong>我一直觉得，我写一个Fragment或Activity是希望别人以更加方便的方式去调用，而不是别人要用我的组件的时候先要看半天代码，这样很浪费时间</strong></p>
<p>#4. ListView的layout_height属性</p>
<p>ListView的<code>layout_height</code>属性一般情况下不允许设置为<code>wrap_content</code>，这样会在ListView滚动的时候非常浪费性能（getView方法会多次调用）</p>
<p>#5. Singleton模板<br>在看Android源码的时候发现这么一个类：</p>
<pre><code><span class="keyword">package</span> android.util;

<span class="comment">/**
 * Singleton helper class for lazily initialization.
 *
 * Modeled after frameworks/base/include/utils/Singleton.h
 *
 * <span class="doctag">@hide</span>
 */</span>
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="keyword">private</span> T mInstance;

    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
            <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) {
                mInstance = create();
            }
            <span class="keyword">return</span> mInstance;
        }
    }
}
</code></pre><p>突然发现这个代码写的真好啊啊…如果你想创建一个单例的话只要继承这个<code>Singleton&lt;T&gt;</code>模板就可以了</p>
<p>但是！因为Android系统源码上加了<code>@hide</code>标注，我们不能直接继承这个<code>android.util.Singleton&lt;T&gt;</code>类。</p>
<p><strong> 我们可以在工程的utils包中写一份一模一样的代码嘛～ </strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录一些好用的开发技巧</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="Note" scheme="http://bxbxbai.gitcafe.io/tags/Note/"/>
    
      <category term="开发经验" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的2014]]></title>
    <link href="http://bxbxbai.gitcafe.io/2015/01/13/my-2014/"/>
    <id>http://bxbxbai.gitcafe.io/2015/01/13/my-2014/</id>
    <published>2015-01-13T12:56:20.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>###<strong>2014，对我来说是非常重要的一年。</strong></p>
<p>因为这一年我研究生毕业，然后在上海工作了。2014年春节过完我就来公司报道了，话说我也在公司待了将近一年了。学到了很多，总结了很多，并且也收获了很多</p>
<a id="more"></a>
<p>一开始，分到任务的时候我就会去想各种解决方法，那时的我唯一的一个想法就是将这个功能完成或bug改掉。后来时间长了以后，我就对客户端的代码慢慢开始熟悉，从界面到各种模块，然后又逐渐熟悉了如何加载图片如何发送HTTP请求，再到各种ContentProvider，从整体上对客户端的代码有了一个认识，这个时候我已经积累了一些经验</p>
<p>后来大家又开始专门对客户端的性能进行优化，我开始熟悉在线歌曲列表的代码的一些细节，并且对歌曲列表滑动的卡顿问题进行优化，慢慢的我也自己学会了使用TraceView工具，也顺便写了一篇<a href="http://bxbxbai.gitcafe.io/2014/10/25/use-trace-view/">文章</a>，这篇文章也在<a href="http://www.weibo.com/5038680568/BuUa9wzgv" target="_blank" rel="external">微博上</a>也一些人转发过</p>
<p>因为需求不断变的复杂，我开始对代码的重用性和可维护性有了认识，代码的可重用性高可以直接提高我们开发的效率，因为有些前面有人开发过的功能可以直接拿来使用。因此，我现在提交的代码也会考虑一些可重用的问题。</p>
<p>2014年这大半年的时间里，我觉得我最大的收获就是，<strong>在做一个新的功能或改一个bug 的时候，应该要想一想还有没有更好的解决办法了？</strong> 这个解决办法在以后需求改动时，够不够灵活，能不能重用以前的代码。如果面对一个新的需求的时候，最好要想到两种以上的解决方案，然后衡量每种方案实现的难易程度，如果以后需求改动，这种方案的改动会不会很麻烦（也就是扩展性和灵活性如何）。综合个方面来选择一个比较好的方案</p>
<p>利用大把的周末时间，我也看了一些大牛的代码，比如Volley和Picasso，有<a href="http://bxbxbai.gitcafe.io/2014/12/24/read-volley-source-code/">很多收获</a>。也自学了如何反编译，反编译了一些客户端来研究他们的架构和某些功能的实现，这一年我的一个主要思考的问题就是，<strong>如何架构一个易于扩展，并且代码重用性高的app</strong>。同时也集合了一些我觉得很好的开源项目，学习他们的代码</p>
<p>这一年也马马虎虎读了几本好书。比如《文明之光》系列（第3本才刚买来呢）、《图解HTTP》、《简约至上——交互设计四策略》、《程序员的思维修炼》、《参与感》，重新看了一遍《暗时间》。《文明之光》系列是吴军博士最新的书，2014年春节我重读了《浪潮之巅》觉得实在太精彩了！《文明之光》目前也只读了两本，非常好看，文笔非常朴实。</p>
<p>另外，在番薯同学的带领下，成为了一名菜驴。在这里要感谢番薯同学！2015要更多的参加户外徒步，更加多的运动</p>
<p>###<strong>2015的计划：</strong></p>
<ul>
<li>首要任务就是，继续深入Android开发，更加深入理解Android 4大组件，熟悉Android的运行原理，建立Android开发的整体框架（包括自定义View，动画），Android开发软件架构，如何去设计一个代码重用高，性能也高的app</li>
<li>学习Material Design，学习有关Material Design的开源库</li>
<li>看8-10本好书，学习互联网金融相关知识</li>
<li>更多的运动，一定要买一辆自行车；多参加户外运动，去一次台湾</li>
</ul>
<p><strong>最后，思考和总结是一个人进步的重要品质</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>###<strong>2014，对我来说是非常重要的一年。</strong></p>
<p>因为这一年我研究生毕业，然后在上海工作了。2014年春节过完我就来公司报道了，话说我也在公司待了将近一年了。学到了很多，总结了很多，并且也收获了很多</p>]]>
    
    </summary>
    
      <category term="2014" scheme="http://bxbxbai.gitcafe.io/tags/2014/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Volley源码分析]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/12/24/read-volley-source-code/"/>
    <id>http://bxbxbai.gitcafe.io/2014/12/24/read-volley-source-code/</id>
    <published>2014-12-24T07:50:22.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>Volley是一个可以让你在Android应用中以非常简单的方式来发送http请求并且处理服务器返回的数据，这样你就可以花更多的时间关心你的业务实现了</p>
<p>前段时间用了一下Volley，发现非常好用，就很好奇Volley是怎么实现的，因为它是Google的人开发的，也好奇大牛们写的代码都是怎么样的？抱着学习的心态来分析一下Volley的源码，也可以为我以后的工作中积累一些好用的解决方案。以后我也会看一下<a href="http://loopj.com/android-async-http/" target="_blank" rel="external">Android-async-http-client</a>是如何来处理发送http请求这类问题的</p>
<p>Volley的使用可以看这篇博客：<a href="http://bxbxbai.github.io/2014/09/14/android-working-with-volley/" target="_blank" rel="external">Volley库的使用介绍</a> ，你可以在这篇博客中找到更多关于Volley的学习资料：<a href="http://bxbxbai.github.io/2014/10/07/android-develop-resource/" target="_blank" rel="external">Android开发资源</a></p>
<a id="more"></a>
<p><strong>首先说明一下，在Volley中每发送一个请求都需要创建一个<code>Request</code>对象，然后将这个<code>Request</code>放入一个<code>RequestQueue</code>中，然后Volley会自动帮你处理这个<code>Request</code></strong>，你只需要处理返回的结果即可</p>
<p>从Volley的源码中可以看出，Volley就是实现了一个生产者消费者问题（<a href="http://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem" target="_blank" rel="external">Producer–consumer problem</a>）。从源码里看，一个消费者（<code>CacheDispatcher</code>）也可以是下一个消费者（<code>NetworkDispatcher</code>）的生产者</p>
<p>##0x0 Volley架构<br>总的来说Volley库的架构非常清晰，源代码也非常好理解，Volley的架构可以用下面这张图来说明：</p>
<p><img src="http://bxbxbai.github.io/img/volley.png" alt="volley"></p>
<p>这张图是Google I/O 2013 大会上演讲的图，我是从Youtube的视频上截下来的。</p>
<p>从这张图上可以很清晰的看见，一个Request被放到RequestQueue中后，马上被<code>CacheDispatcher</code>处理，从名字就可以看出来这是检查Cache的，如果Cache中有数据并且没过期的话Volley就直接将数据返回了</p>
<p>如果<code>CacheDispatcher</code>中没有数据或，数据已经过期了，那么Volley就通过<code>NetworkDispatcher</code>发送一个http请求来获取最新的数据，从图中可以看出有多个线程来发送http请求，也就是说Volley可以同时发送多个http请求</p>
<p>##0x1<br>上面将了Volley处理一个<code>Request</code>的大致流程，那么从源码角度来看Volley是怎么处理的呢？</p>
<p>###0x10 Request<t>类<br>首先来看一下Volley的<code>Request</code>类的签名：</t></p>
<pre><code>public abstract <span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="inheritance">&lt;<span class="parent">T</span></span>&gt; <span class="title">implements</span> <span class="title">Comparable</span><span class="inheritance">&lt;<span class="parent">Request</span></span><span class="inheritance">&lt;<span class="parent">T</span></span>&gt;&gt;</span>
</code></pre><p><code>Request</code>是一个范型，其中<code>T</code>表示这个<code>Request</code>返回的数据类型，并且这个<code>Request</code>是可以相互比较的（实现<code>Comparable</code>接口），<code>Request</code>类实现的<code>Comparable</code>接口就是比较两个<code>Request</code>的priority</p>
<p>Volley自带的<code>Request</code>包含了一下几个：</p>
<ul>
<li><code>ImageRequest</code></li>
<li><code>JsonArrayRequest</code></li>
<li><code>JsonObjectRequest</code></li>
<li><code>JsonRequest</code></li>
<li><code>StringRequest</code></li>
<li><code>ClearCacheRequest</code></li>
</ul>
<p>从字面上可以基本看出每个Request是用来干什么的。</p>
<p>你也可以自定义一个<code>Request&lt;T&gt;</code>，比如说你可以定义一个<code>GsonRequest&lt;T&gt;</code>，当Volley发送一个请求后返回的是一个Java对象（通过Gson将json字符串自动转换成一个Java对象），这样的话写代码就非常方便了</p>
<p>自定义一个<code>Request&lt;T&gt;</code>需要实现<code>Request</code>类的两个抽象方法：</p>
<ul>
<li><code>Response&lt;T&gt; parseNetworkResponse(NetworkResponse response)</code></li>
<li><code>void deliverResponse(T response)</code></li>
</ul>
<p>第一个方法用来说明如何解析这个Response，说白了就是将<code>NetworkResponse</code>转换成<code>Response</code>对象。比如<code>ImageRequest</code>类就是需要将reponse数据转换成一个Bitmap对象</p>
<p>第二个方法是用来告诉Volley如何传递这个解析以后的结果，一般是用一个<code>Response.Listener&lt;T&gt;</code>回调接口来传递这个结果</p>
<p>##0x2 RequestQueue<br>上面讲了如何使用<code>Request</code>类，现在讲讲<code>RequestQueue</code></p>
<p>创建一个<code>RequestQueue</code>，需要4个参数</p>
<ul>
<li><strong>Cache</strong>：Volley使用的缓存，默认是<code>DiskBasedCache</code>（这个Cache为了减少gc，自己实现了一个简单的序列化方法）</li>
<li><strong>Network</strong> ： 这个是<code>RequestQueue</code>用来发送http请求的工具，后面会详细讲</li>
<li><strong>发送http请求的线程数</strong>（默认是4个）：<code>NetworkDispatcher</code> 线程数量</li>
<li><strong>ResponseDelivery</strong> ：用于传递Response，一般是被<code>CacheDispatcher</code>和<code>NetworkDispatcher</code>用于传递从Cache中拿到的或Network返回的HTTP Response</li>
</ul>
<p>####RequestQueue包含的其他东西<br>上面讲的是Volley的<code>RequestQueue</code>可以传入的参数，一个<code>RequestQueue</code>还需要以下东西才能正常运行：</p>
<p><code>AtomicInteger mSequenceGenerator</code> 是一个序列号生成器，它为每一个加入到队列中的Request打上一个序列号</p>
<p><code>PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue</code> 表示在Cache队列中的Request，从最上面的图中可以看到，一个<code>Request</code>被加到队列中后，它首先就进入<code>mCacheQueue</code></p>
<p><code>PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue</code> 表示等待通过<code>Network</code>发送HTTP请求的<code>Request</code>队列。这个和上面的<code>mCacheQueue</code>都是一个优先队列，每一个加入到优先队列中的<code>Request</code>都会按照它的优先级进行排序（如果优先级一样的话，就通过<code>mSequenceGenerator</code>生成的序号进行排序，这部分代码在<code>Request.compareTo</code>中可以看到）</p>
<p><code>Set&lt;Request&lt;?&gt;&gt; mCurrentRequests</code> 是<code>RequestQueue</code>当前正在执行或正在等待的<code>Request</code>，在<code>mCacheQueue</code>或<code>mNetworkQueue</code>中的<code>Request</code>都会被存放到<code>mCurrentRequests</code>列表中。这个列表中的<code>Request</code>可以用来执行<code>RequestQueue.cancelAll</code>操作</p>
<p><code>Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests</code> 这个对象也很有意思，这个map的key是<code>Request</code>的cacheKay，value是一个对应这个cacheKey所有的<code>Request</code></p>
<p>###0x20 创建一个RequestQueue</p>
<p>一般创建一个<code>RequestQueue</code>的方法就是通过下面这句代码：</p>
<pre><code>RequestQueue <span class="built_in">queue</span> = Volley.newRequestQueue(Context);
</code></pre><p>当然，如果你需要自定义的话，就可以通过<code>RequestQueue</code>的构造函数自己new一个<code>RequestQueue</code>。一般来说，一个app中有一个<code>RequestQueue</code>就够了，没必要生成多个队列，生成多个队列会浪费系统的线程资源</p>
<p>在创建一个<code>RequestQueue</code>的时候，Volley已经充分帮我们考虑了一些事情</p>
<p>Android中用来发送HTTP请求的类有<code>HttpUrlConnection</code>和<code>AndroidHttpClient</code>，一般会使用前者，因为Google对它做了很多优化，但是在Android Gingerbread（Android 2.3，API LEVEL = 9）以前，<code>HttpUrlConnection</code>会有一些bug，那么应该使用后者。那为什么不直接使用后者呢？因为Google对前者做了很多优化…=。=</p>
<p>Volley对此也做了相应的判断，Android 2.3以前使用<code>AndroidHttpClient</code>，Android 3.0之后使用<code>HttpUrlConnection</code>，这样就会有相对更好的性能，更节省流量(<a href="http://android-developers.blogspot.com/2011/09/androids-http-clients.html" target="_blank" rel="external">看这里</a>)</p>
<p><code>Network</code>接口对他们进行了封装，对<code>RequestQueue</code>而言只有<code>Network</code>接口，但是真正发送请求的地方在<code>HurlStack.performRequest</code>或<code>HttpClientStack.performRequest</code>方法中，前者使用<code>HttpUrlConnection</code>，后者使用<code>AndroidHttpClient</code></p>
<p>####好处<br><code>RequestQueue</code>只依赖于<code>Network</code>接口，而不依赖于实现，它不必关心<code>Network.performRequest</code>具体的实现方式</p>
<p>###0x21 启动和停止RequestQueue</p>
<p>在<code>RequestQueue</code>生成以后就需要调用<code>RequestQueue.start</code>方法启动</p>
<p><code>RequestQueue.start</code>方法就是启动每一个Dispatcher（每一个Dispatcher就是一个线程）</p>
<pre><code><span class="comment">/**
 * Starts the dispatchers in this queue.
 */</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{
    stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span>
    <span class="comment">// Create the cache dispatcher and start it.</span>
    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
    mCacheDispatcher.start();

    <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) {
        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,
                mCache, mDelivery);
        mDispatchers[i] = networkDispatcher;
        networkDispatcher.start();
    }
}
</code></pre><p>同理<code>RequestQueue.stop</code>方法就是停止每一个Dispatcher，代码就不贴了</p>
<p>###0x22 向RequestQueue中添加Request</p>
<p>每创建一个<code>Request</code>都需要通过<code>RequestQueue.add</code>方法添加到队列中。调用<code>RequestQueue</code>的<code>add</code>方法，这就是生产者消费者问题中，生产者（producer）向池子（queue）里面存放物品（goods），然后消费者从池子（queue）里拿东西</p>
<p>先看代码：</p>
<pre><code><span class="comment">/**
 * Adds a Request to the dispatch queue.
 * @param request The request to service
 * @return The passed-in request
 */</span>
public &lt;T&gt; Request&lt;T&gt; add<span class="params">(Request&lt;T&gt; request)</span> {
    <span class="comment">// Tag the request as belonging to this queue and     add it to the set of current requests.</span>
    request.setRequestQueue<span class="params">(this)</span>;
    <span class="comment">// A</span>
    synchronized <span class="params">(mCurrentRequests)</span> {
        mCurrentRequests.add<span class="params">(request)</span>;
    }

    <span class="comment">// Process requests in the order they are added.</span>
    request.setSequence<span class="params">(getSequenceNumber<span class="params">()</span>)</span>;
    request.addMarker<span class="params">(<span class="string">"add-to-queue"</span>)</span>;

    <span class="comment">// If the request is uncacheable, skip the cache queue and go straight to the network.</span>
    <span class="comment">// B</span>
    <span class="keyword">if</span> <span class="params">(!request.shouldCache<span class="params">()</span>)</span> {
        mNetworkQueue.add<span class="params">(request)</span>;
        return request;
    }

    <span class="comment">// Insert request into stage if there's already a request with the same cache key in flight.</span>
    synchronized <span class="params">(mWaitingRequests)</span> {
        String cacheKey = request.getCacheKey<span class="params">()</span>;
        <span class="comment">// C</span>
        <span class="keyword">if</span> <span class="params">(mWaitingRequests.containsKey<span class="params">(cacheKey)</span>)</span> {
            <span class="comment">// There is already a request in flight. Queue up.</span>
            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get<span class="params">(cacheKey)</span>;
            <span class="keyword">if</span> <span class="params">(stagedRequests == null)</span> {
                stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;<span class="params">()</span>;
            }
            stagedRequests.add<span class="params">(request)</span>;
            mWaitingRequests.put<span class="params">(cacheKey, stagedRequests)</span>;
            <span class="keyword">if</span> <span class="params">(VolleyLog.DEBUG)</span> {
                VolleyLog.v<span class="params">(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey)</span>;
            }
        } <span class="keyword">else</span> {
            <span class="comment">// Insert 'null' queue for this cacheKey, indicating there is now a request in flight.</span>
            <span class="comment">// D</span>
            mWaitingRequests.put<span class="params">(cacheKey, null)</span>;
            mCacheQueue.add<span class="params">(request)</span>;
        }
        return request;
    }
}
</code></pre><p>上面代码就是添加一个<code>Request</code>到队列中的全部操作。我加了A、B、C、D关键处标记，</p>
<ul>
<li><p>A : 首先，将<code>Request</code>加入到<code>mCurrentRequests</code>，表示有一个<code>Request</code>将要被处理，然后这是这个<code>Request</code>的序列号和一个测试标记</p>
</li>
<li><p>B : 检查这个<code>Request</code>是否可以被Cache，如果不可以，就直接放入<code>mNetworkQueue</code>中，由<code>NetworkDispatcher</code>处理，直接发送HTTP请求</p>
</li>
<li><p>C : 接下来，表示<code>Request</code>都可以被Cache的，检查<code>Request</code>的cacheKey字段，如果存在相同cacheKey的<code>Request</code>，就表示可以不处理这个<code>Request</code>了，直接拿别的<code>Request</code>的结果即可，这样可以减少相同<code>Request</code>的发送，减少流量消耗~</p>
</li>
<li><p>D : 如果C不满足的话，就将这个<code>Request</code>放入<code>mCacheQueue</code>队列中，由<code>CacheDispatcher</code>来处理 </p>
</li>
</ul>
<p>###0x23 如何传递Response</p>
<p>当<code>CacheDispatcher</code>或<code>NetworkDispatcher</code>拿到Response以后（不管是Cache中的还是请求HTTP返回的），都会通过一个叫做<code>ResponseDelivery</code>的东西传递出去。</p>
<p>其中，传递HTTP Response真正的地方就在<code>ResponseDelivery</code>的<code>ResponseDeliveryRunnable</code>类中，下面是<code>ResponseDeliveryRunnable</code>类的<code>run</code>方法：</p>
<pre><code> @Override
 public void run<span class="params">()</span> {
     <span class="comment">// If this request has canceled, finish it and don't deliver.</span>
     <span class="keyword">if</span> <span class="params">(mRequest.isCanceled<span class="params">()</span>)</span> {
         mRequest.finish<span class="params">(<span class="string">"canceled-at-delivery"</span>)</span>;
         return;
     }

     <span class="comment">// Deliver a normal response or error, depending.</span>
     <span class="keyword">if</span> <span class="params">(mResponse.isSuccess<span class="params">()</span>)</span> {
         mRequest.deliverResponse<span class="params">(mResponse.result)</span>;
     } <span class="keyword">else</span> {
         mRequest.deliverError<span class="params">(mResponse.error)</span>;
     }

     <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span>
     <span class="comment">// and the request can be finished.</span>
     <span class="keyword">if</span> <span class="params">(mResponse.intermediate)</span> {
         mRequest.addMarker<span class="params">(<span class="string">"intermediate-response"</span>)</span>;
     } <span class="keyword">else</span> {
         mRequest.finish<span class="params">(<span class="string">"done"</span>)</span>;
     }

     <span class="comment">// If we have been provided a post-delivery runnable, run it.</span>
     <span class="keyword">if</span> <span class="params">(mRunnable != null)</span> {
         mRunnable.run<span class="params">()</span>;
     }
}
</code></pre><p>这个方法就会检查这个<code>Response</code>，如果<code>Response</code>是成功的，那么就通过<code>Request.deliverResponse</code>方法传递。</p>
<p>在本文最上面可以看到，<code>Request.deliverResponse</code>是一个抽象方法，每个<code>Request</code>都需要自己实现处理<code>Response</code>的代码，一般都是通过调用<code>Response.Listener</code> 接口来处理结果</p>
<p>##0x3 CacheDispatcher</p>
<p><code>CacheDispatcher</code>是一个专门用来检查Cache的线程，它其实既是消费者也是生产者。它需要以下几样东西：</p>
<ul>
<li><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue</code> ： 等待检查Cache 的Request队列</li>
<li><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue</code> ： 等待发送HTTP请求的Request队列</li>
<li><code>Cache mCache</code> ： Volley使用的Cache，默认就是<code>DiskBasedCache</code></li>
<li><code>ResponseDelivery mDelivery</code> ：如果检查的Cache符合要求（没有过期），就用这个来传递Response</li>
</ul>
<p>从上面图中可以看出，<code>CacheDispatcher</code>对于app来说是一个消费者，它从<code>mCacheQueue</code>中拿Request来检查Cache。对<code>NetworkDispatcher</code>来说，又是一个生产者（如果检查的Cache没有或者Cache已经过期，就向<code>mNetworkQueue</code>中添加Request）</p>
<p>下面就是<code>CacheDispatcher</code>的<code>run</code>方法，从源代码里看一看到<code>CacheDispatcher</code>会一直运行，当<code>mCacheQueue</code>中没有需要处理的<code>Request</code>时，此线程会一直被<code>mCacheQueue.take()</code>方法阻塞，直到<code>RequestQueue</code>向<code>mCacheQueue</code>添加了一个请求。</p>
<pre><code>@Override
public void run<span class="params">()</span> {
    <span class="keyword">if</span> <span class="params">(DEBUG)</span> VolleyLog.v<span class="params">(<span class="string">"start new dispatcher"</span>)</span>;
    Process.setThreadPriority<span class="params">(Process.THREAD_PRIORITY_BACKGROUND)</span>;

    <span class="comment">// Make a blocking call to initialize the cache.</span>
    mCache.initialize<span class="params">()</span>;

    while <span class="params">(<span class="literal">true</span>)</span> {
        try {
            <span class="comment">// Get a request from the cache triage queue, blocking until</span>
            <span class="comment">// at least one is available.</span>
            final Request&lt;?&gt; request = mCacheQueue.take<span class="params">()</span>;
            request.addMarker<span class="params">(<span class="string">"cache-queue-take"</span>)</span>;

            <span class="comment">// If the request has been canceled, don't bother dispatching it.</span>
            <span class="keyword">if</span> <span class="params">(request.isCanceled<span class="params">()</span>)</span> {
                request.finish<span class="params">(<span class="string">"cache-discard-canceled"</span>)</span>;
                continue;
            }

            <span class="comment">// Attempt to retrieve this item from cache.</span>
            Cache.Entry entry = mCache.get<span class="params">(request.getCacheKey<span class="params">()</span>)</span>;
            <span class="keyword">if</span> <span class="params">(entry == null)</span> {
                request.addMarker<span class="params">(<span class="string">"cache-miss"</span>)</span>;
                <span class="comment">// Cache miss; send off to the network dispatcher.</span>
                mNetworkQueue.put<span class="params">(request)</span>;
                continue;
            }

            <span class="comment">// If it is completely expired, just send it to the network.</span>
            <span class="keyword">if</span> <span class="params">(entry.isExpired<span class="params">()</span>)</span> {
                request.addMarker<span class="params">(<span class="string">"cache-hit-expired"</span>)</span>;
                request.setCacheEntry<span class="params">(entry)</span>;
                mNetworkQueue.put<span class="params">(request)</span>;
                continue;
            }

            <span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span>
            request.addMarker<span class="params">(<span class="string">"cache-hit"</span>)</span>;
            Response&lt;?&gt; response = request.parseNetworkResponse<span class="params">(
                    new NetworkResponse<span class="params">(entry.data, entry.responseHeaders)</span>)</span>;
            request.addMarker<span class="params">(<span class="string">"cache-hit-parsed"</span>)</span>;

            <span class="keyword">if</span> <span class="params">(!entry.refreshNeeded<span class="params">()</span>)</span> {
                <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span>
                mDelivery.postResponse<span class="params">(request, response)</span>;
            } <span class="keyword">else</span> {
                <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span>
                <span class="comment">// but we need to also send the request to the network for</span>
                <span class="comment">// refreshing.</span>
                request.addMarker<span class="params">(<span class="string">"cache-hit-refresh-needed"</span>)</span>;
                request.setCacheEntry<span class="params">(entry)</span>;

                <span class="comment">// Mark the response as intermediate.</span>
                response.intermediate = <span class="literal">true</span>;

                <span class="comment">// Post the intermediate response back to the user and have</span>
                <span class="comment">// the delivery then forward the request along to the network.</span>
                mDelivery.postResponse<span class="params">(request, response, new Runnable<span class="params">()</span> {
                    @Override
                    public void run<span class="params">()</span> {
                        try {
                            mNetworkQueue.put<span class="params">(request)</span>;
                        } catch <span class="params">(InterruptedException e)</span> {
                            // Not much we can do about this.
                        }
                    }
                })</span>;
            }

        } catch <span class="params">(InterruptedException e)</span> {
            <span class="comment">// We may have been interrupted because it was time to quit.</span>
            <span class="keyword">if</span> <span class="params">(mQuit)</span> {
                return;
            }
            continue;
        }
    }
}
</code></pre><p>##0x4 NetworkDispatcher</p>
<p><code>NetworkDispatcher</code>和<code>CacheDispatcher</code>非常类似，它也需要4个东西：</p>
<ul>
<li><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue</code> ： 等待发送HTTP请求的Request队列</li>
<li><code>Network mNetwork</code> ： 用于发送HTTP请求的，<code>Network</code>是一个接口</li>
<li><code>Cache mCache</code> ： Volley使用的Cache，默认就是<code>DiskBasedCache</code></li>
<li><code>ResponseDelivery mDelivery</code> ：如果检查的Cache符合要求（没有过期），就用这个来传递Response</li>
</ul>
<p>其中操作的过程也和<code>CacheDispatcher</code>类似，就不贴源码了</p>
<p>##0x5 ImageLoader<br>上面讲的东西大致就构成了Volley库<strong>最核心</strong>的东西，一般的请求json或图片是没有太大问题的。但是Google的工程师又想到为我们广大码农减少工作量，增加了<code>ImageLoader</code>和<code>NetworkImageView</code>这两个东西</p>
<p>其实<code>ImageLoader</code>这个工具和Volley库的整个架构是没有太大关系的，它就是为了更加方便的让我们加载网络图片</p>
<p>创建一个<code>ImageLoader</code>需要两个东西：</p>
<ul>
<li>RequestQueue ： 这个在上面已经说了好多了</li>
<li>ImageCache ： 这是一个接口，Volley没有提供具体的实现，需要自己实现。一般都会实现一个基于内存的<code>LruImageCache</code>，网上也有各种栗子。可以参考<a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a>源码中的<a href="https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso/LruCache.java" target="_blank" rel="external">实现</a></li>
</ul>
<p><code>ImageLoader</code>也是对<code>RequestQueue</code>的一个封装，它也会为创建一个<code>Request&lt;ImageView&gt;</code>，然后把这个Request放到RequestQueue中去下载图片</p>
<p>###0x50 在Volley中如何方便的加载一张图片</p>
<pre><code>ImageLoader loader = new ImageLoader<span class="params">(RequestQueue, ImageCache)</span>;
NetworkImageView imageView = <span class="params">(NetworkImageView)</span>findViewById<span class="params">(R.id.iv_news_pic)</span>;
imageView.setImageUrl<span class="params">(picUrl, loader)</span>;
</code></pre><p>上面3句代码就能够加载网络图片了，是不是很方便。<code>NetworkImageView</code>会计算当前ImageView的宽高，然后创建一个ImageRequest，放入RequestQueue中下载图片。</p>
<p>###0x51 NetworkImageView</p>
<p><code>NetworkImageView</code>是继承<code>ImageView</code>的，比传统的<code>ImageView</code>多了一个加载网络图片的功能</p>
<p>##0x6 最后<br>本文就是详细的分析了Volley库的结构了流程。本文觉得这个库设计的非常好，不管是扩展性还是代码可读性都非常好。</p>
<p><code>RequestQueue</code>就表示Volley运行的整个生命周期，它维护了很多个队列。<code>CacheDispatcher</code>和<code>NetworkDispatcher</code> 分别完成检查Cache和发送HTTP请求的工作。当拿到<code>NetworkResponse</code>数据的时候，会调用<code>Request.parseNetworkResponse</code>方法解析Response结果，最后调用<code>ResponseDeleivery</code>对象来传递解析后的Response结果。</p>
<p>Google还在Volley中加入了<code>ImageLoader</code>和<code>NetworkImageView</code>让我们广大码农以更加方便的方式加载网络图片</p>
<p>###最后的最后</p>
<p>Volley的整个架构实现就是最基本的生产者消费者模式（<a href="http://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem" target="_blank" rel="external">Producer–consumer problem</a>）。这种架构虽然很简单，但是用途也非常广泛，非常值得学习和借鉴！！</p>
<p>也不是说Volley就完美了，最近本人又在学习<a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a>的源码。这是一个非常好的专门用于加载图片的库，它不光可以加载网络图片，还可以用它来加载res目录下的图片、SD卡上的图片、Asset目录下的图片、手机图片库中的图片，而且扩展性也非常好！不说了，下次有机会就写一篇关于<a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a>的源码分析博客</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Volley是一个可以让你在Android应用中以非常简单的方式来发送http请求并且处理服务器返回的数据，这样你就可以花更多的时间关心你的业务实现了</p>
<p>前段时间用了一下Volley，发现非常好用，就很好奇Volley是怎么实现的，因为它是Google的人开发的，也好奇大牛们写的代码都是怎么样的？抱着学习的心态来分析一下Volley的源码，也可以为我以后的工作中积累一些好用的解决方案。以后我也会看一下<a href="http://loopj.com/android-async-http/">Android-async-http-client</a>是如何来处理发送http请求这类问题的</p>
<p>Volley的使用可以看这篇博客：<a href="http://bxbxbai.github.io/2014/09/14/android-working-with-volley/">Volley库的使用介绍</a> ，你可以在这篇博客中找到更多关于Volley的学习资料：<a href="http://bxbxbai.github.io/2014/10/07/android-develop-resource/">Android开发资源</a></p>]]>
    
    </summary>
    
      <category term="Volley 源码分析" scheme="http://bxbxbai.gitcafe.io/tags/Volley-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LayoutInflater.inflate方法解析]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/11/19/make-sense-of-layoutinflater/"/>
    <id>http://bxbxbai.gitcafe.io/2014/11/19/make-sense-of-layoutinflater/</id>
    <published>2014-11-19T04:58:40.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p><code>LayoutInflater.inflate</code>方法应该是Android程序员最常使用的方法之一了，但是如果使用不当，你会碰见很多的坑。。。今天我就碰到了一个，我找到了解决方法，也打算把它记下来。。。</p>
<p>事情是这样的，我有一个<code>LineaLayout</code>，然后在代码中会<code>inflate</code>若干个<code>View</code>添加到这个<code>LineaLayout</code>中，但是坑出现了。。。</p>
<a id="more"></a>
<p>##0x00 一个栗子<br>需要添加到LinearLayout中的View布局文件类似如下（）：</p>
<pre><code><span class="tag">&lt;<span class="title">RelativeLayout</span>
    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"80dp"</span>
    <span class="attribute">android:paddingTop</span>=<span class="value">"5dp"</span>
    <span class="attribute">android:paddingBottom</span>=<span class="value">"5dp"</span>
    <span class="attribute">android:background</span>=<span class="value">"@android:color/holo_green_dark"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">ImageView</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/iv_media_menu_icon"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"24dp"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"24dp"</span>
        <span class="attribute">android:src</span>=<span class="value">"@drawable/ic_mv"</span>
        <span class="attribute">android:layout_centerHorizontal</span>=<span class="value">"true"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">TextView</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_media_menu_text"</span>
        <span class="attribute">android:text</span>=<span class="value">"bxbxbai"</span>
        <span class="attribute">style</span>=<span class="value">"@style/Menu_TextView"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span>
</code></pre><p>这个<code>View</code>的宽固定为<code>80dp</code>，高和父容器一样，然后就是<code>inflate</code>这个View并且添加到这个<code>LinearLayout</code>中（我故意将这个布局文件的background设置一个颜色，这样可以很清晰的看出这个View占的位置）</p>
<pre><code>LinearLayout <span class="keyword">layout</span> = (LinearLayout)findViewById(R.id.<span class="keyword">container</span>);
View view = View.inflate(this, R.<span class="keyword">layout</span>.layout_menu_item, null);
<span class="keyword">layout</span>.addView(view);
</code></pre><p>这样写的话，你就会发现布局文件<code>R.layout.layout_menu_item</code>中的<code>android:layout_width=&quot;80dp&quot;</code>不起作用！！也就是说<code>View.inflate</code>方法忽略了布局文件的宽度设置</p>
<p><img src="http://bxbxbai.github.io/img/inflate0.PNG" alt="inflate"></p>
<p>可是你又可以发现<code>View.inflate</code>方法中还有第三个参数<code>ViewGroup root</code>，Android文档中是这么写的：</p>
<blockquote>
<p>A view group will be the parent. Used to properly inflate the layout_* parameters</p>
</blockquote>
<p>那么可以猜想肯定和这个参数有关，下面改写代码：</p>
<pre><code>LinearLayout <span class="keyword">layout</span> = (LinearLayout)findViewById(R.id.<span class="keyword">container</span>);
View view = View.inflate(this, R.<span class="keyword">layout</span>.layout_menu_item, <span class="keyword">layout</span>);
<span class="keyword">layout</span>.addView(view);
</code></pre><p>你就会发现这样写会崩溃！然后下面这样写就没问题了：</p>
<pre><code>LinearLayout <span class="keyword">layout</span> = (LinearLayout)findViewById(R.id.<span class="keyword">container</span>);
View view = View.inflate(this, R.<span class="keyword">layout</span>.layout_menu_item, <span class="keyword">layout</span>);
</code></pre><p><code>View.inflate</code>方法自动将生成的View添加到了这个<code>ViewGroup root</code>中去了！！</p>
<p><img src="http://bxbxbai.github.io/img/inflate1.PNG" alt="inflate"></p>
<p>你可以<code>inflate</code>多个View，就可以看到下面这样样子了：</p>
<p><img src="http://bxbxbai.github.io/img/inflate2.PNG" alt="inflate"></p>
<p>##0x01 inflate详解<br>其实<code>View.inflate</code>方法是调用了<code>LayoutInflater.from(context).inflate(resource, root, root != null)</code>方法，而inflate方法的三个参数如下：</p>
<ul>
<li>resource： 布局文件的id，比如<code>R.layout.layout_menu_item</code></li>
<li>root：这是一个可选参数，resource布局文件中<code>layout_*</code>参数设置的参照物就是这个root，也就是说<code>inflate</code>方法会根据这个root的大小，将resource布局文件中<code>layout_*</code>参数转换成一个<code>LayoutParam</code>对象</li>
<li>attachToRoot：是否将这个生成的View添加到这个root中去</li>
</ul>
<p><code>inflate</code>方法会返回resource布局文件产生的View</p>
<p>上面栗子中调用了<code>View.inflate(Context context, int resource, ViewGroup root)</code>，这个方法本质上是调用了了<code>LayoutInflater.from(context).inflate(resource, root, root != null)</code>，在这个<code>inflate</code>方法中可以找到下面代码：</p>
<pre><code>// We are supposed <span class="keyword">to</span> attach all the views we found (<span class="built_in">int</span> temp)
// <span class="keyword">to</span> root. <span class="keyword">Do</span> that <span class="built_in">now</span>.
<span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; attachToRoot) {
    root.addView(temp, params)<span class="comment">;</span>
}
</code></pre><p>可见<code>inflate</code>方法自动将这个生成的<code>View</code>添加到了这个<code>root</code>中去了</p>
<p>##0x02 实验</p>
<p>因为可以调用<code>inflate</code>方法的途径有很多，下面就来做实验总结一下：</p>
<p>###实验0<br>布局文件<code>R.layout.layout_menu_item</code> 中<code>android:layout_height=&quot;match_parent&quot;</code> 改为<code>android:layout_height=&quot;10dp&quot;</code></p>
<pre><code>LinearLayout layout = <span class="params">(LinearLayout)</span>findViewById<span class="params">(R.id.container)</span>;
View v1 = LayoutInflater.from<span class="params">(this)</span>.inflate<span class="params">(R.layout.layout_menu_item, null)</span>;
layout.addView<span class="params">(v1)</span>;

<span class="comment">// 结果: layout_height = match_parent layout_width = match_parent</span>
</code></pre><p><img src="http://bxbxbai.github.io/img/inflate_expriment_0.PNG" alt="inflate"></p>
<p>###实验1<br>布局文件<code>R.layout.layout_menu_item</code> 中<code>android:layout_height=&quot;match_parent&quot;</code> 改为<code>android:layout_height=&quot;10dp&quot;</code></p>
<pre><code>LinearLayout layout = <span class="params">(LinearLayout)</span>findViewById<span class="params">(R.id.container)</span>;
View v1 = LayoutInflater.from<span class="params">(this)</span>.inflate<span class="params">(R.layout.layout_menu_item, null)</span>;
layout.addView<span class="params">(v1, <span class="number">200</span>, <span class="number">200</span>)</span>;

<span class="comment">// 结果: layout_height = 200 layout_width = 200</span>
</code></pre><p><img src="http://bxbxbai.github.io/img/inflate_expriment_1.PNG" alt="inflate"></p>
<p>###实验2<br>布局文件<code>R.layout.layout_menu_item</code> 中<code>android:layout_height</code>值改为<code>match_parent</code> </p>
<pre><code>LinearLayout layout = <span class="params">(LinearLayout)</span>findViewById<span class="params">(R.id.container)</span>;
View v1 = LayoutInflater.from<span class="params">(this)</span>.inflate<span class="params">(R.layout.layout_menu_item, layout, <span class="literal">false</span>)</span>;
layout.addView<span class="params">(v1)</span>;

<span class="comment">// 结果: layout_height = match_parent layout_width = 80dp</span>
<span class="comment">// v1 = RelativeLayout 因为 attachRoot = false</span>
</code></pre><p><img src="http://bxbxbai.github.io/img/inflate_expriment_2.PNG" alt="inflate"></p>
<p>###实验3<br>布局文件<code>R.layout.layout_menu_item</code> 中<code>android:layout_height</code>值改为<code>match_parent</code> </p>
<pre><code>LinearLayout layout = <span class="params">(LinearLayout)</span>findViewById<span class="params">(R.id.container)</span>;
View v1 = LayoutInflater.from<span class="params">(this)</span>.inflate<span class="params">(R.layout.layout_menu_item, layout, <span class="literal">true</span>)</span>;
<span class="comment">//layout.addView(v1);</span>

<span class="comment">// 结果: layout_height = match_parent layout_width = 80dp</span>
<span class="comment">// 不需要layout.addView, 因为设置attachRoot=true, 生成的View自动添加到root中去了</span>
<span class="comment">// v1 = root 因为 attachRoot = true</span>
</code></pre><p>##0x03 源码分析</p>
<pre><code><span class="comment"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) &#123;&#10;    synchronized (mConstructorArgs) &#123;&#10;        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &#34;inflate&#34;);&#10;&#10;        final AttributeSet attrs = Xml.asAttributeSet(parser);&#10;        Context lastContext = (Context)mConstructorArgs[0];&#10;        mConstructorArgs[0] = mContext;&#10;        View result = root;&#10;&#10;        try &#123;&#10;            // Look for the root node.&#10;            int type;&#10;            while ((type = parser.next()) != XmlPullParser.START_TAG &#38;&#38;&#10;                    type != XmlPullParser.END_DOCUMENT) &#123;&#10;                // Empty&#10;            &#125;&#10;&#10;            if (type != XmlPullParser.START_TAG) &#123;&#10;                throw new InflateException(parser.getPositionDescription()&#10;                        + &#34;: No start tag found!&#34;);&#10;            &#125;&#10;&#10;            final String name = parser.getName();&#10;            &#10;            if (DEBUG) &#123;&#10;                System.out.println(&#34;**************************&#34;);&#10;                System.out.println(&#34;Creating root view: &#34;&#10;                        + name);&#10;                System.out.println(&#34;**************************&#34;);&#10;            &#125;&#10;&#10;            if (TAG_MERGE.equals(name)) &#123;&#10;                if (root == null || !attachToRoot) &#123;&#10;                    throw new InflateException(&#34;&#60;merge /&#62; can be used only with a valid &#34;&#10;                            + &#34;ViewGroup root and attachToRoot=true&#34;);&#10;                &#125;&#10;&#10;                rInflate(parser, root, attrs, false);&#10;            &#125; else &#123;&#10;                // Temp is the root view that was found in the xml&#10;                View temp;&#10;                if (TAG_1995.equals(name)) &#123;&#10;                    temp = new BlinkLayout(mContext, attrs);&#10;                &#125; else &#123;&#10;                    temp = createViewFromTag(root, name, attrs);&#10;                &#125;&#10;&#10;                ViewGroup.LayoutParams params = null;&#10;&#10;                if (root != null) &#123;&#10;                    if (DEBUG) &#123;&#10;                        System.out.println(&#34;Creating params from root: &#34; +&#10;                                root);&#10;                    &#125;&#10;                    // Create layout params that match root, if supplied&#10;                    params = root.generateLayoutParams(attrs);&#10;                    if (!attachToRoot) &#123;&#10;                        // Set the layout params for temp if we are not&#10;                        // attaching. (If we are, we use addView, below)&#10;                        temp.setLayoutParams(params);&#10;                    &#125;&#10;                &#125;&#10;&#10;                if (DEBUG) &#123;&#10;                    System.out.println(&#34;-----&#62; start inflating children&#34;);&#10;                &#125;&#10;                // Inflate all children under temp&#10;                rInflate(parser, temp, attrs, true);&#10;                if (DEBUG) &#123;&#10;                    System.out.println(&#34;-----&#62; done inflating children&#34;);&#10;                &#125;&#10;&#10;                // We are supposed to attach all the views we found (int temp)&#10;                // to root. Do that now.&#10;                if (root != null &#38;&#38; attachToRoot) &#123;&#10;                    root.addView(temp, params);&#10;                &#125;&#10;&#10;                // Decide whether to return the root that was passed in or the&#10;                // top view found in xml.&#10;                if (root == null || !attachToRoot) &#123;&#10;                    result = temp;&#10;                &#125;&#10;            &#125;&#10;&#10;        &#125; catch (XmlPullParserException e) &#123;&#10;            InflateException ex = new InflateException(e.getMessage());&#10;            ex.initCause(e);&#10;            throw ex;&#10;        &#125; catch (IOException e) &#123;&#10;            InflateException ex = new InflateException(&#10;                    parser.getPositionDescription()&#10;                    + &#34;: &#34; + e.getMessage());&#10;            ex.initCause(e);&#10;            throw ex;&#10;        &#125; finally &#123;&#10;            // Don&#39;t retain static reference on context.&#10;            mConstructorArgs[0] = lastContext;&#10;            mConstructorArgs[1] = null;&#10;        &#125;&#10;&#10;        Trace.traceEnd(Trace.TRACE_TAG_VIEW);&#10;&#10;        return result;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></span>
</code></pre><p>实验3的原因在<strong>inflate详解</strong>中已经介绍过了。</p>
<p>总之原因就在上面代码<code>71-74</code>行，布局文件<code>R.layout.layout_menu_item</code>生成的View会因为<code>attachToRoot</code>参数为<code>true</code>，就将这个生成的<code>View</code>添加到<code>root</code>中去，然后<code>inflate</code>方法会返回这个<code>root</code>的<code>View</code></p>
<p>看上面代码<code>54-60</code>行，如果root不为null的话，就会为这个布局文件<code>R.layout.layout_menu_item</code>生成一个<code>LayoutParam</code>对象，如果<code>attachToRoot</code>参数为<code>false</code>，那么就将这个<code>param</code>对象给这个布局文件的View（看55行）。如果<code>attachToRoot</code>参数为<code>true</code>，那么就在上面代码第70行，将这个布局文件的<code>View</code>和<code>param</code>参数添加到<code>root</code>中。</p>
<p>##0x04 总结</p>
<ol>
<li><p>调用<code>LayoutInflater.inflate</code>方法，并且将root参数设置为<code>null</code>，就等于忽略了xml布局文件中的<code>layout_×</code>参数</p>
</li>
<li><p>如果<code>root</code>不为<code>null</code>，并且<code>attachRoot=true</code>，那么就会根据<code>root</code>生成一个布局文<code>件View</code>的<code>LayoutParam</code>对象，并且将这个<code>View</code>添加到<code>root</code>中去，并且返回这个<code>root</code>的<code>View</code></p>
</li>
<li><p>因此，最好还是使用这个代码吧：<code>View v1 = LayoutInflater.from(this).inflate(R.layout.layout_menu_item, layout, false);</code></p>
</li>
</ol>
<p>##参考</p>
<ol>
<li><p><a href="http://stackoverflow.com/questions/5026926/making-sense-of-layoutinflater" target="_blank" rel="external">Making sense of LayoutInflater</a></p>
</li>
<li><p><a href="http://www.doubleencore.com/2013/05/layout-inflation-as-intended/" target="_blank" rel="external">Layout Inflation as Intended</a></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><code>LayoutInflater.inflate</code>方法应该是Android程序员最常使用的方法之一了，但是如果使用不当，你会碰见很多的坑。。。今天我就碰到了一个，我找到了解决方法，也打算把它记下来。。。</p>
<p>事情是这样的，我有一个<code>LineaLayout</code>，然后在代码中会<code>inflate</code>若干个<code>View</code>添加到这个<code>LineaLayout</code>中，但是坑出现了。。。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发技巧" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
      <category term="经验" scheme="http://bxbxbai.gitcafe.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正确使用Android性能分析工具——TraceView]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/10/25/use-trace-view/"/>
    <id>http://bxbxbai.gitcafe.io/2014/10/25/use-trace-view/</id>
    <published>2014-10-25T02:09:36.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>##前面唠叨<br>最近公司app中有些列表在滑动的时候会有卡顿现象，我就开始着手解决这些问题，解决问题之前首先要分析列表滑动的性能瓶颈在什么地方。因为之前不会正确使用TraceView这个工具，主要是看不懂TraceView界面下方数据指标的值代表什么意思…以前我用<a href="http://bxbxbai.github.io/2014/08/01/the-stopwatch-class/" target="_blank" rel="external">StopWatch</a>类来分析性能，现在觉得弱爆了…不过有些地方<a href="http://bxbxbai.github.io/2014/08/01/the-stopwatch-class/" target="_blank" rel="external">StopWatch</a>工具类还是很简单好用的~</p>
<p>网上可以找了很多博客来介绍这个工具的使用方法，很多都是讲解了一些一些就会的方法，讲一个大概，包括StackOverFlow上我也没有找到很好的讲解TraceView各个数据指标代码什么意思的回答</p>
<p>因为我要解决列表滑动的卡顿问题，就必须要找到导致卡顿现象的原因，我就在StackOverFlow上找着别人零散的回答慢慢琢磨这个工具的使用方法。现在我学会了，至少能看懂每个指标什么意思，<strong>最后发现这个工具实在太强大了！！！</strong></p>
<a id="more"></a>
<p>##TraceView界面 </p>
<p>现来看一下整个界面的图，整个界面包括上下两部分，上面是你测试的进程中每个线程的执行情况，每个线程占一行；下面是每个方法执行的各个指标的值</p>
<p>上面一部分是你测试进程的中每个线程运行的时间线，下图中可以可以看到，主要只有一个main线程在执行，因为我滑动了一下列表，main线程（UI线程）正在进行绘制View呢~~</p>
<p>然后我点击了序号为133的一个方法<code>io.bxbxbai.android.examples.activity.ExpandableLayoutMainActivity$SimpleAdapter.getItemView</code>，就会出现两部分数据：</p>
<ul>
<li>Parents</li>
<li>Children</li>
</ul>
<p>Parents表示调用133这个方法的父方法，可以看到序号为130。Children表示方法133调用的其他方法，可以看到有好几个方法。</p>
<p><img src="http://bxbxbai.github.io/img/trace_view.png" alt="main"></p>
<p>##如何使用TraceView</p>
<p>因为这次我主要是分析列表滑动卡顿问题，我就讲讲我是怎么使用这个工具的，并且我是怎么分析的。</p>
<p>使用TraceView主要有两种方式：</p>
<ol>
<li><p>最简单的方式就是直接打开DDMS，选择一个进程，然后按上面的“Start Method Profiling”按钮，等红色小点变成黑色以后就表示TraceView已经开始工作了。然后我就可以滑动一下列表（现在手机上的操作肯定会很卡，因为Android系统在检测Dalvik虚拟机中每个Java方法的调用，这是我猜测的）。<strong>操作最好不要超过5s，因为最好是进行小范围的性能测试</strong>。然后再按一下刚才按的按钮，等一会就会出现上面这幅图，然后就可以开始分析了。</p>
</li>
<li><p>第2种方式就是使用<code>android.os.Debug.startMethodTracing();</code>和<code>android.os.Debug.stopMethodTracing();</code>方法，当运行了这段代码的时候，就会有一个trace文件在<code>/sdcard</code>目录中生成，也可以调用<code>startMethodTracing(String traceName)</code> 设置trace文件的文件名，最后你可以使用<code>adb pull /sdcard/test.trace /tmp</code> 命令将trace文件复制到你的电脑中，然后用DDMS工具打开就会出现第一幅图了</p>
</li>
</ol>
<p>第一种方式相对来说是一种简单，但是测试的范围很宽泛，第二中方式相对来说精确一点，不过我个人喜欢使用第一种，因为简单，而且它是检测你的某一个<strong>操作</strong>。因为第二中更适合检测某一个方法的性能，其实也没有那种好，看使用的场景和喜好了。。。</p>
<p>##看懂TraceView中的指标</p>
<p><img src="http://bxbxbai.github.io/img/trace_view_metric.png" alt="指标"></p>
<p>其实我今年7月份就已经开始使用TraceView工具了，但是当时不懂其中每个指标的含义，就没注意到它强大的地方。看不懂界面下方表格中的指标，这些数据其实一点意义都没有。</p>
<p>网上包括Android官网也没有对TraceView工具的使用有详细的说明文档，这点确实比较蛋疼。</p>
<p>###纵轴<br>TraceView界面下方表格中纵轴就是每个方法，包括了JDK的，Android SDK的，也有native方法的，当然最重要的就是app中你自己写的方法，有些Android系统的方法执行时间很长，那么有很大的可能就是你app中调用这些方法过多导致的。</p>
<p><strong>每个方法前面都有一个数字，可能是全部方法按照Incl CPU Time 时间的排序序号</strong>（后面会讲到）</p>
<p>点一个方法后可以看到有两部分，一个是Parents，另一个是Children。</p>
<ul>
<li><p>Parent表示调用这个方法的方法，可以叫做父方法</p>
</li>
<li><p>Children表示这个方法中调用的其他方法，可以叫做子方法</p>
</li>
</ul>
<p>###横轴</p>
<p><img src="http://bxbxbai.github.io/img/trace_view_incl_time.png" alt="incl time"></p>
<p>横轴上是很多指标，这些指标表示什么意思真的困扰了我很长一段时间。。。</p>
<p>能够很衡量一个方法性能的指标应该只有时间了吧？ 一个方法肯定就是执行时间越短约好咯~~</p>
<p>####<strong>1. Incl Cpu Time</strong></p>
<p>define <strong>inclusive</strong> ： 全包括的</p>
<p>上图中可以看到<code>0（toplevel）</code> 的Incl Cpu Time 占了100%的时间，这个不是说100%的时间都是它在执行，请看下面代码：</p>
<pre><code>public void top<span class="comment">()</span> {
    a<span class="comment">()</span>;
    b<span class="comment">()</span>;
    c<span class="comment">()</span>;
    d<span class="comment">()</span>;
}
</code></pre><p>Incl Cpu Time表示方法top执行的总时间，假如说方法top的执行时间为10ms，方法a执行了1ms，方法b执行了2ms，方法c执行了3ms，方法d执行了4ms（这里是为了举个栗子，实际情况中方法a、b、c、d的执行总时间肯定比方法top的执行总时间要小一点）。</p>
<p>而且调用方法top的方法的执行时间是100ms，那么：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>Incl Cpu Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td></td>
<td>10%</td>
</tr>
<tr>
<td></td>
<td>a</td>
<td>10%</td>
</tr>
<tr>
<td></td>
<td>b</td>
<td>20%</td>
</tr>
<tr>
<td></td>
<td>c</td>
<td>30%</td>
</tr>
<tr>
<td></td>
<td>d</td>
<td>40%</td>
</tr>
</tbody>
</table>
<p>从上面图中可以看到：<br><code>toplevel</code>的 Incl Cpu Time 是1110.943，而<code>io.bxbxbai.android.examples.activity.ExpandableLayoutMainActivity$SimpleAdapter.getItemView</code>方法的Incl Cpu Time为12.859，说明后者的Incl Cpu Time % 约为1.2%</p>
<p>这个指标表示 <span style="color:red"> <strong>这个方法以及这个方法的子方法（比如top方法中的a、b、c、d方法）一共执行的时间</strong></span></p>
<p>####<strong>2. Excl Cpu Time</strong></p>
<p>理解了Incl Cpu Time以后就可以很好理解Excl Cpu Time了，还是上面top方法的栗子：</p>
<p>方法top 的 Incl Cpu Time 减去 方法a、b、c、d的Incl Cpu Time 的时间就是方法top的Excl Cpu Time 了</p>
<p>####<strong>3. Incl Real Time</strong></p>
<p>这个感觉和Incl Cpu Time 差不多，第7条会讲到。</p>
<p>####<strong>4. Excl Real Time</strong></p>
<p>同上</p>
<p>####<strong>5. Calls + Recur Calls / Total </strong></p>
<p>这个指标非常重要！</p>
<p><strong>它表示这个方法执行的次数</strong>，这个指标中有两个值，一个Call表示这个方法调用的次数，Recur Call表示递归调用次数，看下图：</p>
<p><img src="http://bxbxbai.github.io/img/trace_view_recur_call.png" alt="Recur"></p>
<p>我选中了一个方法，可以看到这个方法的<code>Calls + Recur Calls</code> 值是14 + 0，表示这个方法调用了14次，但是没有递归调用</p>
<p>从Children这一块来看，很多方法调用都是13的倍数，说明父方法中有一个判断，但是这不是重点，有些Child方法调用Calls为26，这说明了这些方法被调用了两遍，是不是可能存在重复调用的情况？这些都是可能可以优化性能的地方。</p>
<p>####<span style="color:red"> <strong>6. Cpu Time / Call </strong></span></p>
<p><strong>重点来了！！！！！！！！！！</strong></p>
<p><img src="http://bxbxbai.github.io/img/trace_view_cpu_time.png" alt="cpu time"></p>
<p>这个指标应该说是最重要的，从上图可以看到，133这个方法的调用次数为20次，而它的Incl Cpu Time为12.859ms，那么133方法每一次执行的时间是0.643ms（<strong>133这个方法是<code>SimpleAdapter</code>的<code>getItemView</code>方法</strong>）</p>
<p>对于一个<code>adapter</code>的<code>getView</code>方法来说0.643ms是非常快的（因为这个<code>adapter</code>中只有一个<code>TextView</code>，我为了测试用的）</p>
<p>如果<code>getView</code>方法执行时间很长，那么必然导致列表滑动的时候产生卡顿现象，可以在<code>getView</code>方法的Children方法列表中找到耗时最长的方法，分析出现问题的原因：</p>
<ul>
<li>是因为有过多的计算？</li>
<li>还是因为有读取SD卡的操作？</li>
<li>还是因为<code>adapter</code>中<code>View</code>太复杂了？</li>
<li>还是因为需要有很多判断，设置<code>View</code>的显示还是隐藏</li>
<li>还是因为其他原因…</li>
</ul>
<p>####<strong>7. Real Time / Call </strong></p>
<p>Real Time 和 Cpu Time 我现在还不太明白它们的区别，我的理解应该是:</p>
<ul>
<li>Cpu Time 应该是某个方法占用CPU的时间</li>
<li>Real Time 应该是这个方法的实际运行时间</li>
</ul>
<p><strong>为什么它们会有区别呢？可能是因为CPU的上下文切换、阻塞、GC等原因方法的实际执行时间要比Cpu Time 要稍微长一点。</strong></p>
<p>##总结<br>TraceView是一个非常强大的性能分析工具，因为Android 官网对这个工具的使用介绍文档很少，而且一些中文博客中写的也都是抄来抄去，没有讲到底怎么使用。</p>
<p>最近我在做这方面的性能分析，就慢慢琢磨了这么工具的使用，发现非常强大，写下来总结一下。    </p>
<p>Android的性能分析工具还有很多，比如：</p>
<ul>
<li>Eclipse Memory Analyzer Tool 来分析Android app的内存使用</li>
<li>Dump UI Hierarchy for UI Atomator，分析UI层级</li>
<li>systrace</li>
<li>其他</li>
</ul>
<p>下图这一条工具栏中有很多性能分析工具~~~<br><img src="http://bxbxbai.github.io/img/ddms_tools.png" alt="TOOLS"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>##前面唠叨<br>最近公司app中有些列表在滑动的时候会有卡顿现象，我就开始着手解决这些问题，解决问题之前首先要分析列表滑动的性能瓶颈在什么地方。因为之前不会正确使用TraceView这个工具，主要是看不懂TraceView界面下方数据指标的值代表什么意思…以前我用<a href="http://bxbxbai.github.io/2014/08/01/the-stopwatch-class/">StopWatch</a>类来分析性能，现在觉得弱爆了…不过有些地方<a href="http://bxbxbai.github.io/2014/08/01/the-stopwatch-class/">StopWatch</a>工具类还是很简单好用的~</p>
<p>网上可以找了很多博客来介绍这个工具的使用方法，很多都是讲解了一些一些就会的方法，讲一个大概，包括StackOverFlow上我也没有找到很好的讲解TraceView各个数据指标代码什么意思的回答</p>
<p>因为我要解决列表滑动的卡顿问题，就必须要找到导致卡顿现象的原因，我就在StackOverFlow上找着别人零散的回答慢慢琢磨这个工具的使用方法。现在我学会了，至少能看懂每个指标什么意思，<strong>最后发现这个工具实在太强大了！！！</strong></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发技巧" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
      <category term="经验" scheme="http://bxbxbai.gitcafe.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[整理一些比较好的Android开发教程]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/10/07/android-develop-resource/"/>
    <id>http://bxbxbai.gitcafe.io/2014/10/07/android-develop-resource/</id>
    <published>2014-10-07T15:08:32.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>这些都是我在学习Android开发过程中觉得比较好的教程和博客，在这里整理一下，方便自己也方便大家学习使用。</p>
<p>欢迎补充~</p>
<p>##介绍LoaderManager的使用</p>
<ol>
<li><p>Life before Loaders(part 1)<br><a href="http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html" target="_blank" rel="external">http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html</a></p>
</li>
<li><p>Understanding the LoaderManager(part 2)<br><a href="http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html" target="_blank" rel="external">http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html</a></p>
</li>
<li><p>Implementing Loaders(part 3)<br><a href="http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html" target="_blank" rel="external">http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html</a></p>
</li>
<li><p>Tutorial: AppListLoader(part 4)<br><a href="http://www.androiddesignpatterns.com/2012/09/tutorial-loader-loadermanager.html" target="_blank" rel="external">http://www.androiddesignpatterns.com/2012/09/tutorial-loader-loadermanager.html</a><br><a href="https://github.com/alexjlockwood/AppListLoader" target="_blank" rel="external">https://github.com/alexjlockwood/AppListLoader</a></p>
</li>
<li><p>How to use Loaders in Android<br><a href="http://www.grokkingandroid.com/using-loaders-in-android/" target="_blank" rel="external">http://www.grokkingandroid.com/using-loaders-in-android/</a></p>
</li>
</ol>
<a id="more"></a>
<h2 id="介绍Volley的使用">介绍Volley的使用</h2><ol>
<li><p>Android库Volley的使用介绍<br><a href="http://bxbxbai.github.io/2014/09/14/android-working-with-volley/" target="_blank" rel="external">http://bxbxbai.github.io/2014/09/14/android-working-with-volley/</a></p>
</li>
<li><p>Android Volley完全解析（博主是Android牛人，博客质量很高！）<br><a href="http://blog.csdn.net/guolin_blog/article/details/17482095" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/17482095</a> （Android Volley完全解析(一)，初识Volley的基本用法）<br><a href="http://blog.csdn.net/guolin_blog/article/details/17482165" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/17482165</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/17612763" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/17612763</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/17656437" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/17656437</a></p>
</li>
<li><p>Android 官方的Volley使用介绍（看完基本就知道怎么用了）<br>3.1 Transmitting Network Data using Volley<br><a href="http://developer.android.com/training/volley/index.html" target="_blank" rel="external">http://developer.android.com/training/volley/index.html</a><br>3.2 Sending a Simple Request（发送一个简单的request）<br><a href="http://developer.android.com/training/volley/simple.html" target="_blank" rel="external">http://developer.android.com/training/volley/simple.html</a><br>3.3 Setting up a RequestQueue（创建一个请求队列）<br><a href="http://developer.android.com/training/volley/requestqueue.html" target="_blank" rel="external">http://developer.android.com/training/volley/requestqueue.html</a><br>3.4 Making a Standard Request（使用volley自带的request类）<br><a href="http://developer.android.com/training/volley/request.html" target="_blank" rel="external">http://developer.android.com/training/volley/request.html</a><br>3.5 Implementing a Custom Request(创建你自己的request类这里的栗子就是创建一个GsonRequest)<br><a href="http://developer.android.com/training/volley/request-custom.html" target="_blank" rel="external">http://developer.android.com/training/volley/request-custom.html</a><br>3.6 Google I/O 2013，Volley：Fast, Networking in Android(Google IO大会上的演讲，自备梯子)<br><a href="https://www.youtube.com/watch?v=yhv8l9F44qo" target="_blank" rel="external">https://www.youtube.com/watch?v=yhv8l9F44qo</a><br>3.7 使用Volley的一个demo 工程<br><a href="https://github.com/bxbxbai/FeedListViewDemo" target="_blank" rel="external">https://github.com/bxbxbai/FeedListViewDemo</a></p>
</li>
</ol>
<h2 id="Android开发实例">Android开发实例</h2><ol>
<li><p>Android Working with ActionBar（讲解Actionbar的使用）<br><a href="http://www.androidhive.info/2013/11/android-working-with-action-bar/" target="_blank" rel="external">http://www.androidhive.info/2013/11/android-working-with-action-bar/</a></p>
</li>
<li><p>创建一个类似Hello SMS的菜单<br><a href="http://blog.robinchutaux.com/blog/how-to-create-a-menu-like-hello-sms/" target="_blank" rel="external">http://blog.robinchutaux.com/blog/how-to-create-a-menu-like-hello-sms/</a></p>
</li>
<li><p>一个开源的知乎专栏App<br><a href="https://github.com/bxbxbai/ZhuanLan" target="_blank" rel="external">https://github.com/bxbxbai/ZhuanLan</a></p>
</li>
</ol>
<h2 id="Android_开源项目集合">Android 开源项目集合</h2><ol>
<li><p>最流行的Android组件大全（包括工具和教程，UI组件，类库，游戏引擎和H5应用）<br><a href="http://colobu.com/2014/08/15/android-components-collection/" target="_blank" rel="external">http://colobu.com/2014/08/15/android-components-collection/</a><br><a href="http://blog.daimajia.com/android-library-collection/" target="_blank" rel="external">http://blog.daimajia.com/android-library-collection/</a></p>
</li>
<li><p>码农周刊（Android和iOS干货精选）<br><a href="http://baoz.me/452378" target="_blank" rel="external">http://baoz.me/452378</a></p>
</li>
</ol>
<h2 id="Android_应用性能优化（包含Android_官方文档）">Android 应用性能优化（包含Android 官方文档）</h2><ol>
<li><p>Managing Your App’s Memory<br><a href="http://developer.android.com/training/articles/memory.html" target="_blank" rel="external">http://developer.android.com/training/articles/memory.html</a></p>
</li>
<li><p>Performance Tips<br><a href="http://developer.android.com/training/articles/perf-tips.html" target="_blank" rel="external">http://developer.android.com/training/articles/perf-tips.html</a></p>
</li>
<li><p>Improving Layout Performance<br><a href="http://developer.android.com/training/improving-layouts/index.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/index.html</a></p>
</li>
<li><p>Sending Operations to Multiple Threads<br><a href="http://developer.android.com/training/multiple-threads/index.html" target="_blank" rel="external">http://developer.android.com/training/multiple-threads/index.html</a></p>
</li>
<li><p>Performance Tuning On Android(作者详细介绍了各种分析Android性能的方法以及优化策略，非常好的一篇博客)<br><a href="http://blog.venmo.com/hf2t3h4x98p5e13z82pl8j66ngcmry/performance-tuning-on-android" target="_blank" rel="external">http://blog.venmo.com/hf2t3h4x98p5e13z82pl8j66ngcmry/performance-tuning-on-android</a></p>
</li>
<li><p>Using Android TraceView<br><a href="http://blog.cindypotvin.com/using-android-traceview-in-eclipse/" target="_blank" rel="external">http://blog.cindypotvin.com/using-android-traceview-in-eclipse/</a></p>
</li>
<li><p>分析你的App内存使用情况<br><a href="https://developer.android.com/tools/debugging/debugging-memory.html" target="_blank" rel="external">https://developer.android.com/tools/debugging/debugging-memory.html</a></p>
</li>
<li><p>Android Performance Case Study<br><a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="external">http://www.curious-creature.org/2012/12/01/android-performance-case-study/</a></p>
</li>
</ol>
<h2 id="Android_ContentProvider介绍">Android ContentProvider介绍</h2><ol>
<li><p>Content Provider Basics<br><a href="http://www.grokkingandroid.com/android-tutorial-content-provider-basics/" target="_blank" rel="external">http://www.grokkingandroid.com/android-tutorial-content-provider-basics/</a></p>
</li>
<li><p>Using Content Providers<br><a href="http://www.grokkingandroid.com/android-tutorial-using-content-providers/" target="_blank" rel="external">http://www.grokkingandroid.com/android-tutorial-using-content-providers/</a></p>
</li>
<li><p>Writing your own Content Provider<br><a href="http://www.grokkingandroid.com/android-tutorial-writing-your-own-content-provider/" target="_blank" rel="external">http://www.grokkingandroid.com/android-tutorial-writing-your-own-content-provider/</a></p>
</li>
<li><p>Better Performance with ContentProviderOperation<br><a href="http://www.grokkingandroid.com/better-performance-with-contentprovideroperation/" target="_blank" rel="external">http://www.grokkingandroid.com/better-performance-with-contentprovideroperation/</a></p>
</li>
</ol>
<h2 id="Android_开发经验">Android 开发经验</h2><p>CodePath Android:  <a href="http://guides.codepath.com/android" target="_blank" rel="external">http://guides.codepath.com/android</a></p>
<ol>
<li><p>Working with the TextView<br><a href="http://guides.codepath.com/android/Working-with-the-TextView" target="_blank" rel="external">http://guides.codepath.com/android/Working-with-the-TextView</a></p>
</li>
<li><p>Working with the ImageView<br><a href="http://guides.codepath.com/android/Working-with-the-ImageView" target="_blank" rel="external">http://guides.codepath.com/android/Working-with-the-ImageView</a></p>
</li>
<li><p>Endless Scrolling with AdapterViews（可以无限加载更多的AdapterView，很巧妙的继承了OnScrollListener）<br><a href="http://guides.codepath.com/android/Endless-Scrolling-with-AdapterViews" target="_blank" rel="external">http://guides.codepath.com/android/Endless-Scrolling-with-AdapterViews</a></p>
</li>
<li><p>Android事件传递机制（有栗子，有分析）<br><a href="http://www.infoq.com/cn/articles/android-event-delivery-mechanism" target="_blank" rel="external">http://www.infoq.com/cn/articles/android-event-delivery-mechanism</a></p>
</li>
<li><p>Android Tips Round-Up, Part 5（Android开发技巧）<br><a href="http://blog.danlew.net/2014/05/28/android-tips-round-up-part-5/" target="_blank" rel="external">http://blog.danlew.net/2014/05/28/android-tips-round-up-part-5/</a></p>
</li>
<li><p>Activity和Fragment的生命周期图<br><a href="http://bxbxbai.github.io/img/complete_android_fragment_lifecycle.png" target="_blank" rel="external">http://bxbxbai.github.io/img/complete_android_fragment_lifecycle.png</a></p>
</li>
<li><p>使用GestureDetector（ListView中左右滑动显示菜单也是使用GestureDetector）<br><a href="http://ryanharter.com/blog/2014/10/08/using-gestures/" target="_blank" rel="external">http://ryanharter.com/blog/2014/10/08/using-gestures/</a> （博文中有图片方法缩小的栗子，可能需要梯子）<br><a href="https://github.com/rharter/android-gesture-detectors" target="_blank" rel="external">https://github.com/rharter/android-gesture-detectors</a> （github上使用GestureDetector的一个项目）</p>
</li>
</ol>
<h2 id="Android开发在线工具">Android开发在线工具</h2><ol>
<li><p>在线创建Holo主题（Android Holo Colors Generator）<br><a href="http://android-holo-colors.com/" target="_blank" rel="external">http://android-holo-colors.com/</a></p>
</li>
<li><p>在线创建ActionBar样式（Android Action Bar Style Generator）<br><a href="http://jgilfelt.github.io/android-actionbarstylegenerator/" target="_blank" rel="external">http://jgilfelt.github.io/android-actionbarstylegenerator/</a></p>
</li>
<li><p>在线创建Button样式（Android Button Maker）<br><a href="http://angrytools.com/android/button/" target="_blank" rel="external">http://angrytools.com/android/button/</a></p>
</li>
<li><p>SQLite数据加密<br><a href="https://www.zetetic.net/sqlcipher/" target="_blank" rel="external">https://www.zetetic.net/sqlcipher/</a></p>
</li>
<li><p>在线创建Icon资源（包括：Launch Icon，Actionbar和tab icon，Notification Icon等等）<br><a href="http://romannurik.github.io/AndroidAssetStudio/index.html" target="_blank" rel="external">http://romannurik.github.io/AndroidAssetStudio/index.html</a></p>
</li>
<li><p>Device Frame Generator<br><a href="http://f2prateek.com/android-device-frame-generator/" target="_blank" rel="external">http://f2prateek.com/android-device-frame-generator/</a></p>
</li>
<li><p>Android Simple Nine-patch Generator<br><a href="http://romannurik.github.io/AndroidAssetStudio/nine-patches.html" target="_blank" rel="external">http://romannurik.github.io/AndroidAssetStudio/nine-patches.html</a></p>
</li>
<li><p>AndroidDrawableFactory<br><a href="https://github.com/tizionario/AndroidDrawableFactory" target="_blank" rel="external">https://github.com/tizionario/AndroidDrawableFactory</a></p>
</li>
<li><p>Android Layout Resource Binder(根据xml布局文件，生成findViewById 的Java代码)<br><a href="http://android.lineten.net/layout.php" target="_blank" rel="external">http://android.lineten.net/layout.php</a></p>
</li>
<li><p>Android Fragment Code Generator<br><a href="http://techisfun.github.io/pages/android-fragment-generator/" target="_blank" rel="external">http://techisfun.github.io/pages/android-fragment-generator/</a></p>
</li>
<li><p>Android ContentProvider Generator<br><a href="https://github.com/BoD/android-contentprovider-generator" target="_blank" rel="external">https://github.com/BoD/android-contentprovider-generator</a></p>
</li>
<li><p>SelectorChapek for Android（快速生成Select文件）<br><a href="https://github.com/inmite/android-selector-chapek" target="_blank" rel="external">https://github.com/inmite/android-selector-chapek</a></p>
</li>
<li><p>Android开发工具整理<br><a href="https://github.com/inferjay/AndroidDevTools" target="_blank" rel="external">https://github.com/inferjay/AndroidDevTools</a><br><a href="http://www.androiddevtools.cn/" target="_blank" rel="external">http://www.androiddevtools.cn/</a></p>
</li>
</ol>
<h2 id="Android_Design">Android Design</h2><ol>
<li><p><strong>台湾人翻译的Material Design文档（非常好！）</strong><br><a href="http://wcc723.gitbooks.io/google_design_translate/content/material-design-introduction.html" target="_blank" rel="external">http://wcc723.gitbooks.io/google_design_translate/content/material-design-introduction.html</a></p>
</li>
<li><p>Android Design 非官方文档（中文翻译）<br><a href="http://adchs.github.io/" target="_blank" rel="external">http://adchs.github.io/</a></p>
</li>
<li><p>Google 开源的Material Design Icons<br><a href="http://google.github.io/material-design-icons/" target="_blank" rel="external">http://google.github.io/material-design-icons/</a><br><a href="https://github.com/google/material-design-icons" target="_blank" rel="external">https://github.com/google/material-design-icons</a></p>
</li>
<li><p>Android Desgin规范<br><a href="http://www.androiddesign.tips/" target="_blank" rel="external">http://www.androiddesign.tips/</a><br><a href="http://petrnohejl.github.io/Android-Cheatsheet-For-Graphic-Designers/" target="_blank" rel="external">http://petrnohejl.github.io/Android-Cheatsheet-For-Graphic-Designers/</a></p>
</li>
<li><p>Material Design Center:<br><a href="https://github.com/lightSky/MaterialDesignCenter" target="_blank" rel="external">https://github.com/lightSky/MaterialDesignCenter</a></p>
</li>
</ol>
<h2 id="很不错的Android开源库">很不错的Android开源库</h2><ol>
<li><p>第一必须是Volley，上面已经列出链接了</p>
</li>
<li><p>Android Asynchronous Http Client（又是一个异步http通信库，也是非常简单好用）<br><a href="http://loopj.com/android-async-http/" target="_blank" rel="external">http://loopj.com/android-async-http/</a></p>
</li>
<li><p>Butter Knife（你再也不需要老是调用findViewById了！！！功能超级强大！！）<br><a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="external">http://jakewharton.github.io/butterknife/</a></p>
</li>
<li><p>Android Smart Image View（可以从Url或者联系人地址簿中加载图片，图片会自动缓存到内存和SD卡上）<br><a href="http://loopj.com/android-smart-image-view/" target="_blank" rel="external">http://loopj.com/android-smart-image-view/</a></p>
</li>
<li><p>Square公司的Android开源项目<br><a href="http://square.github.io/#android" target="_blank" rel="external">http://square.github.io/#android</a></p>
</li>
<li><p>ActiveAndroid项目（SQLite数据的ORM框架）<br><a href="https://github.com/pardom/ActiveAndroid/wiki/Getting-started" target="_blank" rel="external">https://github.com/pardom/ActiveAndroid/wiki/Getting-started</a><br><a href="https://github.com/pardom/ActiveAndroid" target="_blank" rel="external">https://github.com/pardom/ActiveAndroid</a></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这些都是我在学习Android开发过程中觉得比较好的教程和博客，在这里整理一下，方便自己也方便大家学习使用。</p>
<p>欢迎补充~</p>
<p>##介绍LoaderManager的使用</p>
<ol>
<li><p>Life before Loaders(part 1)<br><a href="http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html">http://www.androiddesignpatterns.com/2012/07/loaders-and-loadermanager-background.html</a></p>
</li>
<li><p>Understanding the LoaderManager(part 2)<br><a href="http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html">http://www.androiddesignpatterns.com/2012/07/understanding-loadermanager.html</a></p>
</li>
<li><p>Implementing Loaders(part 3)<br><a href="http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html">http://www.androiddesignpatterns.com/2012/08/implementing-loaders.html</a></p>
</li>
<li><p>Tutorial: AppListLoader(part 4)<br><a href="http://www.androiddesignpatterns.com/2012/09/tutorial-loader-loadermanager.html">http://www.androiddesignpatterns.com/2012/09/tutorial-loader-loadermanager.html</a><br><a href="https://github.com/alexjlockwood/AppListLoader">https://github.com/alexjlockwood/AppListLoader</a></p>
</li>
<li><p>How to use Loaders in Android<br><a href="http://www.grokkingandroid.com/using-loaders-in-android/">http://www.grokkingandroid.com/using-loaders-in-android/</a></p>
</li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发资源" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90/"/>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android库Volley的使用介绍]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/09/14/android-working-with-volley/"/>
    <id>http://bxbxbai.gitcafe.io/2014/09/14/android-working-with-volley/</id>
    <published>2014-09-14T06:48:39.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://developer.android.com/training/volley/index.html" target="_blank" rel="external">Android Volley</a> 是Google开发的一个网络lib，可以让你更加简单并且快速的访问网络数据。Volley库的网络请求都是异步的，你不必担心异步处理问题。</p>
<a id="more"></a>
<p>Volley的优点：</p>
<ol>
<li>请求队列和请求优先级</li>
<li>请求Cache和内存管理</li>
<li>扩展性性强</li>
<li>可以取消请求</li>
</ol>
<p>##下载和编译volley.jar</p>
<ul>
<li>需要安装git，ant，android sdk</li>
</ul>
<p>clone代码：<br><code>git clone https://android.googlesource.com/platform/frameworks/volley</code></p>
<ul>
<li>编译jar：<br><code>android update project -p . 
ant jar</code></li>
</ul>
<ul>
<li><p>添加volley.jar到你的项目中</p>
<p><strong><em>不过已经有人将volley的代码放到github上了：</em></strong><br><a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a>，你可以使用更加简单的方式来使用volley：</p>
</li>
</ul>
<p>###Maven</p>
<p>format: jar</p>
<pre><code><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.mcxiaoke.volley<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>library<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><hr>
<p>###Gradle</p>
<p>format: jar</p>
<p><code>compile &#39;com.mcxiaoke.volley:library:1.0.6&#39;</code></p>
<p>##Volley工作原理图<br><img src="http://bxbxbai.github.io/img/volley.png" alt="Volley"></p>
<p>##创建Volley 单例<br>使用volley时，必须要创建一个请求队列<code>RequestQueue</code>，使用请求队列的最佳方式就是将它做成一个单例，整个app使用这么一个请求队列。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppController</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>{

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = AppController.class
        .getSimpleName();

<span class="keyword">private</span> RequestQueue mRequestQueue;
<span class="keyword">private</span> ImageLoader mImageLoader;

<span class="keyword">private</span> <span class="keyword">static</span> AppController mInstance;

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{
    <span class="keyword">super</span>.onCreate();
    mInstance = <span class="keyword">this</span>;
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> AppController <span class="title">getInstance</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> mInstance;
}

<span class="function"><span class="keyword">public</span> RequestQueue <span class="title">getRequestQueue</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (mRequestQueue == <span class="keyword">null</span>) {
        mRequestQueue = Volley.newRequestQueue(getApplicationContext());
    }

    <span class="keyword">return</span> mRequestQueue;
}

<span class="function"><span class="keyword">public</span> ImageLoader <span class="title">getImageLoader</span><span class="params">()</span> </span>{
    getRequestQueue();
    <span class="keyword">if</span> (mImageLoader == <span class="keyword">null</span>) {
        mImageLoader = <span class="keyword">new</span> ImageLoader(<span class="keyword">this</span>.mRequestQueue,
                <span class="keyword">new</span> LruBitmapCache());
    }
    <span class="keyword">return</span> <span class="keyword">this</span>.mImageLoader;
}

<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addToRequestQueue</span><span class="params">(Request&lt;T&gt; req, String tag)</span> </span>{
    <span class="comment">// set the default tag if tag is empty</span>
    req.setTag(TextUtils.isEmpty(tag) ? TAG : tag);
    getRequestQueue().add(req);
}

<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addToRequestQueue</span><span class="params">(Request&lt;T&gt; req)</span> </span>{
    req.setTag(TAG);
    getRequestQueue().add(req);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelPendingRequests</span><span class="params">(Object tag)</span> </span>{
    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) {
        mRequestQueue.cancelAll(tag);
    }
}
}
</code></pre><p>另外，你还需要一个Cache来存放请求的图片：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruBitmapCache</span> <span class="keyword">extends</span> <span class="title">LruCache</span>&lt;<span class="title">String</span>, <span class="title">Bitmap</span>&gt; <span class="title">implement</span> <span class="title">ImageCache</span> </span>{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">getDefaultLruCacheSize</span><span class="params">()</span> </span>{
        <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);
        <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">8</span>;

        <span class="keyword">return</span> cacheSize;
    }

    <span class="function"><span class="keyword">public</span> <span class="title">LruBitmapCache</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>(getDefaultLruCacheSize());
    }

    <span class="function"><span class="keyword">public</span> <span class="title">LruBitmapCache</span><span class="params">(<span class="keyword">int</span> sizeInKiloBytes)</span> </span>{
        <span class="keyword">super</span>(sizeInKiloBytes);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>{
        <span class="keyword">return</span> value.getRowBytes() * value.getHeight() / <span class="number">1024</span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">Bitmap <span class="title">getBitmap</span><span class="params">(String url)</span> </span>{
        <span class="function"><span class="keyword">return</span> <span class="title">get</span><span class="params">(url)</span></span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">putBitmap</span><span class="params">(String url, Bitmap bitmap)</span> </span>{
        put(url, bitmap);
    }
}
</code></pre><p>别忘记在<code>AndroidManifest.xml</code>文件中添加<code>android.permission.INTERNET</code>权限。</p>
<p>##创建Json请求<br>volley自带了<code>JsonObjectRequest</code>和<code>JsonArrayRequest</code>分别来处理Json对象请求和Json数据请求（但是voley没有使用gson库写一个GsonRequest，发送一个request，volley直接返回一个java对象，不过我们可以自己写）。</p>
<p>###创建json object请求<br>发送一个请求只要这么简单，创建一个<code>JsonRequest</code>对象，写好response回调接口，并把这个请求放到请求队列中就可以了。<code>JsonArrayRequest</code>也类似。</p>
<pre><code><span class="comment">// Tag used to cancel the request</span>
String tag_json_obj = <span class="string">"json_obj_req"</span>;
String url = <span class="string">"http://api.androidhive.info/volley/person_object.json"</span>;

JsonObjectRequest jsonObjReq = <span class="keyword">new</span> JsonObjectRequest(Method.GET,url, <span class="keyword">null</span>,
            <span class="keyword">new</span> Response.Listener&lt;JSONObject&gt;() {

                <span class="annotation">@Override</span>
                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(JSONObject response)</span> </span>{
                    Log.d(TAG, response.toString());
                }
            }, <span class="keyword">new</span> Response.ErrorListener() {

                <span class="annotation">@Override</span>
                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError <span class="keyword">error</span>)</span> </span>{
                    VolleyLog.d(TAG, <span class="string">"Error: "</span> + <span class="keyword">error</span>.getMessage());
                }
            });

<span class="comment">// Adding request to request queue</span>
AppController.getInstance().addToRequestQueue(jsonObjReq, tag_json_obj);
</code></pre><h2 id="创建String请求">创建String请求</h2><p><code>StringRequest</code>可以用来请求任何string类型的数据：json，xml，文本等等。</p>
<pre><code><span class="comment">// Tag used to cancel the request</span>
String  tag_string_req = <span class="string">"string_req"</span>;

String url = <span class="string">"http://api.androidhive.info/volley/string_response.html"</span>;

ProgressDialog pDialog = new ProgressDialog<span class="params">(this)</span>;
pDialog.setMessage<span class="params">(<span class="string">"Loading..."</span>)</span>;
pDialog.show<span class="params">()</span>;     

StringRequest strReq = new StringRequest<span class="params">(Method.GET,
            url, new Response.Listener&lt;String&gt;<span class="params">()</span> {

                @Override
                public void onResponse<span class="params">(String response)</span> {
                    Log.d<span class="params">(TAG, response.toString<span class="params">()</span>)</span>;
                    pDialog.hide<span class="params">()</span>;

                }
            }, new Response.ErrorListener<span class="params">()</span> {

                @Override
                public void onErrorResponse<span class="params">(VolleyError error)</span> {
                    VolleyLog.d<span class="params">(TAG, <span class="string">"Error: "</span> + error.getMessage<span class="params">()</span>)</span>;
                    pDialog.hide<span class="params">()</span>;
                }
            })</span>;

<span class="comment">// Adding request to request queue</span>
AppController.getInstance<span class="params">()</span>.addToRequestQueue<span class="params">(strReq, tag_string_req)</span>;
</code></pre><h2 id="创建POST请求">创建POST请求</h2><p>上面说的都是GET请求，下面来说一下POST请求，与GET请求不同的是，只要在创建请求的时候将请求类型改为POST请求，并且override <code>Request</code>的getParams方法即可。</p>
<pre><code><span class="comment">// Tag used to cancel the request</span>
<span class="built_in">String</span> tag_json_obj = <span class="string">"json_obj_req"</span>;

<span class="built_in">String</span> url = <span class="string">"http://api.androidhive.info/volley/person_object.json"</span>;
ProgressDialog pDialog = <span class="literal">new</span> ProgressDialog(this);
pDialog<span class="built_in">.</span>setMessage(<span class="string">"Loading..."</span>);
pDialog<span class="built_in">.</span>show();     

    JsonObjectRequest jsonObjReq = <span class="literal">new</span> JsonObjectRequest(Method<span class="built_in">.</span>POST,
            url, <span class="built_in">null</span>,
            <span class="literal">new</span> Response<span class="built_in">.</span>Listener&lt;JSONObject&gt;() {

                @Override
                <span class="keyword">public</span> <span class="literal">void</span> onResponse(JSONObject response) {
                    <span class="keyword">Log</span><span class="built_in">.</span>d(<span class="built_in">TAG</span>, response<span class="built_in">.</span>toString());
                    pDialog<span class="built_in">.</span>hide();
                }
            }, <span class="literal">new</span> Response<span class="built_in">.</span>ErrorListener() {

                @Override
                <span class="keyword">public</span> <span class="literal">void</span> onErrorResponse(VolleyErr<span class="subst">or</span> err<span class="subst">or</span>) {
                    VolleyLog<span class="built_in">.</span>d(<span class="built_in">TAG</span>, <span class="string">"Error: "</span> + err<span class="subst">or</span><span class="built_in">.</span>getMessage());
                    pDialog<span class="built_in">.</span>hide();
                }
            }) {

        @Override
        <span class="keyword">protected</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; getParams() {
            <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="keyword">params</span> = <span class="literal">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();
            <span class="keyword">params</span><span class="built_in">.</span>put(<span class="string">"name"</span>, <span class="string">"Androidhive"</span>);
            <span class="keyword">params</span><span class="built_in">.</span>put(<span class="string">"email"</span>, <span class="string">"abc@androidhive.info"</span>);
            <span class="keyword">params</span><span class="built_in">.</span>put(<span class="string">"password"</span>, <span class="string">"password123"</span>);

            <span class="keyword">return</span> <span class="keyword">params</span>;
        }

    };

<span class="comment">// Adding request to request queue</span>
AppController<span class="built_in">.</span>getInstance()<span class="built_in">.</span>addToRequestQueue(jsonObjReq, tag_json_obj);
</code></pre><p>##添加请求头部信息</p>
<pre><code><span class="comment">// Tag used to cancel the request</span>
<span class="keyword">String</span> tag_json_obj = <span class="string">"json_obj_req"</span>;

<span class="keyword">String</span> url = <span class="string">"http://api.androidhive.info/volley/person_object.json"</span>;

ProgressDialog pDialog = <span class="keyword">new</span> ProgressDialog(<span class="keyword">this</span>);
pDialog.setMessage(<span class="string">"Loading..."</span>);
pDialog.show();     

JsonObjectRequest jsonObjReq = <span class="keyword">new</span> JsonObjectRequest(Method.POST,url, <span class="keyword">null</span>,<span class="keyword">new</span> Response.Listener&lt;<span class="keyword">JSONObject</span>&gt;() {
    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> onResponse(<span class="keyword">JSONObject</span> response) {
        Log.d(TAG, response.toString());
        pDialog.hide();
    }
}, <span class="keyword">new</span> Response.ErrorListener() {
    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> onErrorResponse(VolleyError error) {
        VolleyLog.d(TAG, <span class="string">"Error: "</span> + error.getMessage());
        pDialog.hide();
    }
}) {

<span class="comment">/**
* Passing some request headers
* */</span>
@Override
<span class="keyword">public</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; getHeaders() <span class="keyword">throws</span> AuthFailureError {
    <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; headers = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();
    headers.put(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>);
    headers.put(<span class="string">"apiKey"</span>, <span class="string">"xxxxxxxxxxxxxxx"</span>);
    <span class="keyword">return</span> headers;
}
};
<span class="comment">// Adding request to request queue</span>
AppController.getInstance().addToRequestQueue(jsonObjReq, tag_json_obj);
</code></pre><p>##创建Image请求<br>Volley库中自带了<code>NetworkImageView</code>类，这个<code>ImageView</code>可以自动使用volley下载图片</p>
<p>###用<code>NetworkImageView</code>加载图片<br>首先，说明一下，加载图片的原理：</p>
<p><code>NetworkImageView</code>加载图片需要一个ImageLoader和一个图片URL，这个ImageLoader对象需要一个请求队列对象和ImageCahe对象。调用<code>NetworkImageView</code>的setUrl方法后，首先会判断当前ImageView的URL和新传入的URL是否一致，如果相同，就不用再发送http请求了，如果不同，那么就使用ImageLoader对象来发送http请求获取图片。</p>
<pre><code>ImageLoader imageLoader = AppController.getInstance<span class="params">()</span>.getImageLoader<span class="params">()</span>;
<span class="comment">// If you are using NetworkImageView</span>
imgNetWorkView.setImageUrl<span class="params">(Const.URL_IMAGE, imageLoader)</span>;
</code></pre><p>加载一个图片只要这么简单~~~</p>
<p>###用ImageView来加载图片<br>这个过程和<code>NetworkImageView</code>类似</p>
<pre><code>ImageLoader imageLoader = AppController.getInstance().getImageLoader();

<span class="comment">// If you are using normal ImageView</span>
imageLoader.get(Const.URL_IMAGE, <span class="keyword">new</span> ImageListener() {

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError <span class="keyword">error</span>)</span> </span>{
        Log.e(TAG, <span class="string">"Image Load Error: "</span> + <span class="keyword">error</span>.getMessage());
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(ImageContainer response, <span class="keyword">boolean</span> arg1)</span> </span>{
        <span class="keyword">if</span> (response.getBitmap() != <span class="keyword">null</span>) {
            <span class="comment">// load image into imageview</span>
            imageView.setImageBitmap(response.getBitmap());
        }
    }
});
</code></pre><p>可以再简单一点：</p>
<pre><code>// Loading image <span class="keyword">with</span> placeholder <span class="literal">and</span> error image
imageLoader.get(<span class="keyword">Const</span>.URL_IMAGE, ImageLoader.getImageListener(imageView, R.drawable.ico_loading, R.drawable.ico_error))<span class="comment">;</span>
</code></pre><p><code>ImageLoader.getImageListener</code>方法中已经写了一个默认的<code>ImageListener</code>了</p>
<p>##Volley Cache<br>volley中自带了强大的cache机制来管理请求cache，这会减少网络请求次数和用户等待时间。</p>
<p>###从请求Cache中加载请求</p>
<pre><code><span class="keyword">Cache</span> <span class="keyword">cache</span> = AppController<span class="built_in">.</span>getInstance()<span class="built_in">.</span>getRequestQueue()<span class="built_in">.</span>getCache();
Entry entry = <span class="keyword">cache</span><span class="built_in">.</span>get(url);
<span class="keyword">if</span>(entry != <span class="built_in">null</span>){
    try {
        <span class="built_in">String</span> <span class="built_in">data</span> = <span class="literal">new</span> <span class="built_in">String</span>(entry<span class="built_in">.</span><span class="built_in">data</span>, <span class="string">"UTF-8"</span>);
        <span class="comment">// handle data, like converting it to xml, json, bitmap etc.,</span>
    } catch (UnsupportedEncodingException e) {      
        e<span class="built_in">.</span>printStackTrace();
        }
    }
}<span class="keyword">else</span>{
    <span class="comment">// Cached response doesn't exists. Make network call here</span>
}
</code></pre><p>###使请求缓存失效<br>失效并不意味这删除，Volley还会继续使用缓存的对象直到从服务器上获取到了新的数据，新的数据会覆盖旧的数据。</p>
<pre><code>AppController.getInstance<span class="params">()</span>.getRequestQueue<span class="params">()</span>.getCache<span class="params">()</span>.invalidate<span class="params">(url, <span class="literal">true</span>)</span>;
</code></pre><p>###关闭Cache<br>如果你想将某一个请求的Cache功能关闭，直接调用<code>Request</code>的setShouldCache()方法就可以：</p>
<pre><code><span class="comment">// String request</span>
StringRequest stringReq = <span class="literal">new</span> StringRequest(<span class="attribute">...</span><span class="built_in">.</span>);

<span class="comment">// disable cache</span>
stringReq<span class="built_in">.</span>setShouldCache(<span class="literal">false</span>);
</code></pre><p>###将某一URL的Cache删除<br>调用<code>Cache</code>的<code>remove</code>方法可以删除这个URL的cache:</p>
<pre><code><span class="tag">AppController</span><span class="class">.getInstance</span>()<span class="class">.getRequestQueue</span>()<span class="class">.getCache</span>()<span class="class">.remove</span>(<span class="tag">url</span>);
</code></pre><p>###删除所有的Cache</p>
<pre><code><span class="tag">AppController</span><span class="class">.getInstance</span>()<span class="class">.getRequestQueue</span>()<span class="class">.getCache</span>()<span class="class">.clear</span>();
</code></pre><p>##取消请求<br>在你添加一个请求到请求队列中的时候，你可以发现，<code>addToRequestQueue(request, tag)</code>方法还接受一个tag参数，这个tag就是用来标记某一类请求的，这样就可以取消这个tag的所有请求了：</p>
<pre><code>String tag_json_arry = <span class="string">"json_req"</span>;
ApplicationController.getInstance<span class="params">()</span>.getRequestQueue<span class="params">()</span>.cancelAll<span class="params">(<span class="string">"feed_request"</span>)</span>;
</code></pre><p>##请求优先级<br>在创建一个request的时候可以Override <code>Request</code>方法的<code>getPriority</code>方法返回一个优先级，优先级分为：Normal, Low, Immediate, High</p>
<pre><code><span class="keyword">private</span> Priority priority = Priority.HIGH;

StringRequest strReq = <span class="keyword">new</span> StringRequest(Method.<span class="keyword">GET</span>,
            <span class="keyword">Const</span>.URL_STRING_REQ, <span class="keyword">new</span> <span class="built_in">Response</span>.Listener&lt;<span class="built_in">String</span>&gt;() {

                @Override
                <span class="keyword">public</span> void onResponse(<span class="built_in">String</span> <span class="built_in">response</span>) {
                    <span class="built_in">Log</span>.d(TAG, <span class="built_in">response</span>.toString());
                    msgResponse.setText(<span class="built_in">response</span>.toString());
                    hideProgressDialog();

                }
            }, <span class="keyword">new</span> <span class="built_in">Response</span>.ErrorListener() {

                @Override
                <span class="keyword">public</span> void onErrorResponse(VolleyError <span class="keyword">error</span>) {
                    VolleyLog.d(TAG, <span class="string">"Error: "</span> + <span class="keyword">error</span>.getMessage());
                    hideProgressDialog();
                }
            }) {
        @Override
        <span class="keyword">public</span> Priority getPriority() {
            return priority;
        }

    };
</code></pre><p>##Missing! 创建xml请求<br>就像创建Gson请求一样，你可以自定义一个<code>XMLRequest</code>类来请求xml数据</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://developer.android.com/training/volley/index.html">Android Volley</a> 是Google开发的一个网络lib，可以让你更加简单并且快速的访问网络数据。Volley库的网络请求都是异步的，你不必担心异步处理问题。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="volley" scheme="http://bxbxbai.gitcafe.io/tags/volley/"/>
    
      <category term="开发经验" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Stopwatch工具类]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/08/01/the-stopwatch-class/"/>
    <id>http://bxbxbai.gitcafe.io/2014/08/01/the-stopwatch-class/</id>
    <published>2014-08-01T11:45:01.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>现在我的一部分工作就是优化客户端的性能，比如优化列表快速滑动卡顿现象。</p>
<a id="more"></a>
<p>一个很好的办法就是使用DDMS的Method Profiling功能，它可以生成一个表格来显示app中所有执行的方法的执行时间，占cpu运行的百分比，还有图形化的显示。功能很强大！</p>
<p>但是，有的时候是跨线程工作的，比如，我获得要发送一个http请求到http请求返回时的时间，这个它就无能为力了（或许可能我没有发现这个功能）；还比如，我要获得从sd卡上读一个文件所需的时间。</p>
<p>一个最原始的方法就是</p>
<pre><code>long <span class="operator"><span class="keyword">start</span> = SystemClock.uptimeMillis();</span>
//<span class="operator"><span class="keyword">do</span> something
<span class="keyword">Log</span>.<span class="keyword">i</span>(TAG, <span class="string">"time: "</span> + (SystemClock.uptimeMillis() - <span class="keyword">start</span>));</span>
</code></pre><p>这样就可以获得这段代码的运行时间了，我发现在测试Adapter的<code>getView</code>方法性能时很管用。因为ListView快速滑动时卡顿最主要的原因就是<code>getView</code>方法执行时间过长，我的测试过程中发现<code>getView</code>方法的执行时间不能超过10ms（当然这个在不同手机上运行时间不一样）。也就是如果在一个手机上<code>getView</code>方法执行时间超过10ms，这个列表快速滑动时就会产生卡顿现象。</p>
<p>但是Adapter中可能有很多方法，我要在每个方法中都像上面那样写么？我不要烦死了？</p>
<p>然后，我就从秒表中获得启发，我可不可以也像秒表一样写一个类来对每个方法测试它的运行时间呢？</p>
<p>下面这个类就诞生了，其实这个类很简单，你只需要在你需要测试时间的方法A前写一句：</p>
<pre><code>StopWatch.<span class="keyword">begin</span>(<span class="variable">"bxbxbai"</span>);
</code></pre><p>这就相当于按了一下秒表（StopWatch工具就是在HashMap中添加了一条记录），然后在方法A后面写一句：</p>
<pre><code>StopWatch.<span class="keyword">end</span>(<span class="string">"bxbxbai"</span>);
</code></pre><p>这就相当于按了一下秒表，系统在Log中输出了方法A的的运行时间，并且把tag删除。</p>
<pre><code>StopWatch.lap<span class="params">(<span class="string">"bxbxbai"</span>)</span>;
</code></pre><p>这个方法不会删除tag，它会输出当前时间到打tag的时候的时间间隔，就是秒表的计次功能。</p>
<p>不光如此，这个类还支持跨进程，比如，我在A线程中执行begin方法，我可以在一个Callback中执行end方法，输出总共的执行时间。</p>
<script src="https://gist.github.com/bxbxbai/6278750.js"></script>

]]></content>
    <summary type="html">
    <![CDATA[<p>现在我的一部分工作就是优化客户端的性能，比如优化列表快速滑动卡顿现象。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发工具" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我如何理解Java中抽象类和接口]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/07/20/understood_abstract_class_and_interface/"/>
    <id>http://bxbxbai.gitcafe.io/2014/07/20/understood_abstract_class_and_interface/</id>
    <published>2014-07-20T03:17:42.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>在面试中我们经常被问到：<strong>Java中抽象类和接口的区别是什么？</strong></p>
<a id="more"></a>
<p>然后，我们就大说一通抽象类可以有方法，接口不能有实际的方法啦；一个类只能继承一个抽象类，却可以继承多个接口啦，balabala一大堆，就好像把标准答案熟练的说出来一样。</p>
<p><a href="http://www.importnew.com/12399.html" target="_blank" rel="external">抽象类和接口</a>这篇文章讲到了他们的区别和联系，它们确实有很多相似的地方，但是从本质上看，或从语言的设计角度来看，这不是它们最本质的区别。</p>
<p>##不卖关子，我个人对这两个的理解：</p>
<blockquote>
<p>类是具体实例的抽象，比如一个json字符串的抽象；而抽象类就是类的抽象；接口就是抽象类的抽象，<strong>接口更像是一种协议</strong></p>
</blockquote>
<p>听我慢慢道来~</p>
<p>##吐槽<br>首先，我必须吐槽一下这种面试，我认为面试官凡事问出这种类似“说说抽象类和接口的区别”，“说说进程和线程的区别”等等问题，都是不负责的表现。</p>
<p>为什么呢？</p>
<p>一个原因就是，面试官对想要招的人完全没有自己的评价标准，另一个原因就是对面试者不负责。这种问题根本不能考验面试者的水平。</p>
<p>那么，如果我来面试别人，我会问：<strong>请你说说你怎么理解抽象类和接口；如果要你向你外婆解释进程和线程的区别，你会怎么解释？</strong></p>
<p>我觉得这可以考验面试者对问题的理解程度，我想微软的面试题（你如何向你奶奶解释Excel）一样，考验一个人对某一事物的理解程度（虽然，至今我还不能很好的想明白这个问题 -。-）</p>
<p>##抽象类和接口的区别<br>说到抽象类和接口，就必须要说到类。</p>
<p><strong>一个类就是对现实事物的抽象。</strong></p>
<p>比如定义一个BenzCar类，就需要对现实的奔驰汽车有很好的抽象（当然奔驰汽车有好多系列，这里不钻牛角尖）。也就是说如果你要造一辆奔驰汽车，就需要BenzCar这个类（这辆奔驰汽车就是内存中的一个Instance）。</p>
<p><strong>那么抽象类就是对类的抽象。</strong></p>
<p>怎么理解呢？就是说有很多汽车厂商一起定义一种规范（Car类），说要造一辆汽车就需要有发动机，轮胎，音响设备…（这些就相当于抽象方法），具体用什么发动机，轮胎，音响设备由每个汽车厂商自己去完成。这样就有各种汽车了，奔驰牌的，宝马牌的，丰田牌的…</p>
<p><strong>接口就是对抽象类的抽象</strong></p>
<p>这只是我个人的理解。</p>
<p>在我们日常生活中可以看到各种“接口”，电源插座就是一种。开始我是看到耗子叔的博客在开始理解“控制翻转”这个概念的——<a href="http://coolshell.cn/articles/9949.html" target="_blank" rel="external">IoC/DIP其实是一种管理思想| 酷壳- CoolShell.cn</a>。后来我就想，这个东西其实无处不在，制造电源插座的厂和制造电器的厂只要约定一种“接口”——两口插座或三口插座，当然每个国家的接口都不一样，不同接口之间的转换就需要用适配器了。</p>
<p>其实程序中也一样，比如所有的交通工具可以抽象为一个接口<code>Drivable</code>（<em>可能由于经验原因，我考虑的不是很完善</em>），表示实现这个接口的类创建的对象（比如：汽车，飞机，轮船等等）都是可以驾驶的</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Drivable</span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span>(<span class="params"></span>)</span>;
}
</code></pre><p>然后，我们就可以创建一个<code>AbstractCar</code>类，表示这个对所有汽车类的一个抽象，所有可以驾驶的汽车都必须继承这个类，这个抽象类中规定了一些抽象方法，比如<code>getEngine()</code>方法，这说明每种汽车的引擎都不太一样，需要在子类中自定义（<em>当然，你也可以继承<code>AbstractCar</code>类，对所有可能具有相同引擎的汽车进行一层抽象</em>）。</p>
<p>为什么对<code>Drivable</code>的<code>drive()</code>方法进行了默认实现，但是默认实现中却直接抛出了异常呢？</p>
<p>其实这是一种实现接口的方法，还有一种方法就是将<code>drive()</code>设为abstract。这两种实现方式，我觉得从功能上讲是一样的，但是从类设计上讲是不同的。</p>
<p>下面代码中的实现，我是参考了<code>java.util.AbstractList&lt;E&gt;</code>中<code>add(int location, E object)</code>方法的设计，它的文档中写到：</p>
<blockquote>
<pre><code>* <span class="property">@throws</span> UnsupportedOperationException
*                <span class="keyword">if</span> adding <span class="keyword">to</span> <span class="keyword">this</span> List <span class="keyword">is</span> <span class="keyword">not</span> supported.
</code></pre></blockquote>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCar</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Engine <span class="title">getEngine</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Wheel <span class="title">getWheel</span><span class="params">()</span></span>;

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>{
        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();
    }
    <span class="comment">// 省略其他方法和属性</span>
}
</code></pre><p>那么上面这段代码中的<code>drive()</code>可以理解为：</p>
<blockquote>
<p>默认情况下“汽车”是不能开的，你实现了一个汽车类后，需要Override这个方法，实现自己的<code>drive</code>方法</p>
</blockquote>
<p>##以java容器中的List举例</p>
<p><img src="http://bxbxbai.github.io/img/full_container_taxonomy.png" alt="Full Container Taxonomy" title="Full Container Taxonomy"></p>
<p>到源码里面找，你就会发现<code>List&lt;E&gt;</code>的继承关系最顶层的就是<code>Iterable</code>，就表示说List是可以<strong>遍历</strong>的，而且它还会产生一个<code>Iterator</code>接口对象。这表示一个列表可以通过这个<strong>迭代器</strong>来遍历。</p>
<p>这就像上面说的，所有的交通工具都是可以<strong>驾驶</strong>的一样，所有的列表都是可以遍历的。</p>
<p>一层一层往下，类就变得更加具体。</p>
<p>##最后</p>
<p>为什么接口可以继承？</p>
<p>其实这个原理很简单。因为总有一个最本质的<strong>协议</strong>来约束大家，比如所有的交通工具都是可以驾驶的，所有的容易都是可以遍历的。然后<strong>协议</strong>会渐渐变得更加具体：</p>
<pre><code><span class="type">Iterable</span> &lt;- <span class="type">Collection</span> &lt;- <span class="type">List</span> &lt;- <span class="type">AbstractList</span> &lt;- <span class="type">List</span>
</code></pre><p><strong>从下往上看，就是一层比一层抽象。</strong></p>
<p>就像我在文章开头说的，</p>
<ul>
<li>你用<code>ArrayList</code>类可以创建很多个对象，<code>ArrayList</code>就是这些对象的一次抽象</li>
<li>而<code>AbstractList</code>是对<code>ArratList</code>的一次抽象，你用<code>AbstractList</code>可以创建<code>ArrayList</code>，也可以创建<code>Stack</code>，或<code>LinkedList</code>等</li>
<li><code>List</code>接口就是对所有的列表类的抽象</li>
<li><code>Collection</code>就是对所有单一元素的容器的抽象</li>
<li><code>Iterable</code>就是一个最高层次的抽象了，表示所有的容器都是可以遍历的</li>
</ul>
<p>###注：<br>应该有很多我考虑不周全的地方，欢迎大家指正并且讨论</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在面试中我们经常被问到：<strong>Java中抽象类和接口的区别是什么？</strong></p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://bxbxbai.gitcafe.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Context，什么是Context？]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/07/16/context/"/>
    <id>http://bxbxbai.gitcafe.io/2014/07/16/context/</id>
    <published>2014-07-16T12:44:29.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://www.doubleencore.com/2013/06/context/" target="_blank" rel="external">http://www.doubleencore.com/2013/06/context/</a></p>
<p>###译者注：<br>找到一篇好文章，在开发过程中，经常会使用context对象，但是却不知道context是个什么东西，也不知道<code>getApplicationContext()</code> 和 <code>getContext()</code> 如何工作。特地翻译这篇文章，刚开始翻译，英语也不好，有错误还请大家指正。</p>
<a id="more"></a>
<p>###译文：</p>
<blockquote>
<p><code>Context</code>应该是Android应用开发中最常使用的元素吧？它也应该是最滥用的元素。</p>
</blockquote>
<p><code>Context</code>对象是最常见的对象，经常用于参数传递，因此也会出现一些你意想不到的情况。加载资源文件，启动一个新的<code>Activit</code>y，获取一个系统服务，获取内部文件路径和创建view全部（这些仅仅是一部分）都需要一个<code>Context</code>对象来完成这些操作。我们想做的是给你展示<code>Context</code>如何工作，以及提供一些建议会（希望会）让你在开发中更合理的使用<code>Context</code>。</p>
<p>##Context类型<br>并不是所有的Context对象都相同，根据Android应用组件的不同，可以分为以下几种：</p>
<p><strong>Application</strong>：它是应用程序的一个单例，它可以通过Activity或Service的<code>getApplication()</code>方法获取，也可以在任何继承<code>Context</code>类的的对象中通过<code>getApplicationContext()</code>来获取。不管它是怎么获取的，这些方法返回的都是App中同一个实例。</p>
<p><strong>Activity/Service</strong>：它们继承自<code>ContextWrapper</code>，<code>ContextWrapper</code>实现了<code>Context</code>同样的API，但是隐藏了内部<code>Context</code>对象的方法调用，<code>Context</code>也是<code>ContextWrapper</code>的父类。每当系统创建一个<code>Activity</code>或<code>Service</code>对象的时候，它也为它们创建了新的<code>ContextWrapper</code>对象。每个<code>Activity</code>或<code>Service</code>对象，包括他们对应的context对象都是唯一的。</p>
<p><strong>BroadcastReceiver</strong>：它并不拥有<code>Context</code>对象，但是系统在一个新的广播到来的时候通过<code>onReceiver()</code>方法传入一个<code>Context</code>对象，这是一个<code>ReceiverRestrictedContext</code>，它的两个主要方法，<code>registerReceiver()</code>和<code>bindService()</code>都被禁用了。每一次receiver处理一个广播，传入的Context对象都是一个新的实例。</p>
<p><strong>ContentProvider</strong>：同样也不是一个<code>Context</code>对象，但是在创建的时候会通过<code>getContext()</code>方法传入一个context对象。如果<code>ContentProvider</code>是在本地调用的话（在同一个进程中），那么这会返回一个应用单例。然而，如果是在不同的进程中调用的话，它会新建一个context对象表示当前provider运行的进程。</p>
<p>##Saved References<br>第一个问题是，我们想在一个对象中保存一个Context对象的引用，并且这个对象的生命周期超过了你保存的Context对象。比如：创建一个需要一个Context对象的单例来加载文件资源或访问一个ContentProvider，并且在这个单例中保存当前Activity或Service的引用。</p>
<p><strong>Bad Singleton</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomManager</span> {
    <span class="keyword">private</span> <span class="keyword">static</span> CustomManager sInstance;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomManager <span class="title">getInstance</span>(<span class="params">Context context</span>) </span>{
        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) {
            sInstance = <span class="keyword">new</span> CustomManager(context);
        }

        <span class="keyword">return</span> sInstance;
    }

    <span class="keyword">private</span> Context mContext;

    <span class="function"><span class="keyword">private</span> <span class="title">CustomManager</span>(<span class="params">Context context</span>) </span>{
        mContext = context;
    }
}
</code></pre><p>这里的问题在于，我们并不知道<code>Context</code>从哪里来，并且如果单例保存了<code>Activity</code>或<code>Service</code>的引用，如果它们被销毁了，这样是不安全的。这个问题是因为单例在类里面保存了一个静态引用。这就意味着那个对象，以及这个对象引用的所有对象都不会被gc回收。如果<code>Context</code>对象是一个<code>Activity</code>，我们就会始终持有这个<code>Activity</code>的所有View以及其他可能很大的对象，最终导致内存泄露。</p>
<p>为了防止出现这种情况，我们可以修改这个类让它持有<code>Application Context</code>：</p>
<p><strong>Better Singleton：</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomManager</span> {
    <span class="keyword">private</span> <span class="keyword">static</span> CustomManager sInstance;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomManager <span class="title">getInstance</span>(<span class="params">Context context</span>) </span>{
        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) {
            <span class="comment">//Always pass in the Application Context</span>
            sInstance = <span class="keyword">new</span> CustomManager(context.getApplicationContext());
        }

        <span class="keyword">return</span> sInstance;
    }

    <span class="keyword">private</span> Context mContext;

    <span class="function"><span class="keyword">private</span> <span class="title">CustomManager</span>(<span class="params">Context context</span>) </span>{
        mContext = context;
    }
}
</code></pre><p>现在，不管context对象是从哪里传入的，因为现在单例持有的是<code>Application Context</code>，这个是安全的，因为<code>Application Context</code> 本身就是一个单例，因此不会造成内存泄露。还有一个类似的问题就是在一个后台线程（background thread）或一个延时<code>Handler</code>中持有一个对<code>Context</code>的引用。</p>
<p>既然<code>Application Context</code>有那么多好处，我们为什么不用<code>Application Context</code>来处理一切呢？这个问题的答案就是，前面提到过的，是因为</p>
<p><strong>这些Context并不都是相同的</strong>。</p>
<p>##Context的作用<br>从上文中可以知道，Context有多种来源，而不同来源的Context所具有的通用操作也不一样，下表列出了各种不同Context 的作用域：</p>
<table>
<thead>
<tr>
<th>.</th>
<th style="text-align:center">Application</th>
<th style="text-align:center">Activity</th>
<th style="text-align:center">Service</th>
<th style="text-align:center">ContentProvider</th>
<th style="text-align:center">BroadcastReceiver</th>
</tr>
</thead>
<tbody>
<tr>
<td>Show a Dialog</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>Start an Activity</td>
<td style="text-align:center">NO<code>1</code></td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO<code>1</code></td>
<td style="text-align:center">NO<code>1</code></td>
<td style="text-align:center">NO<code>1</code></td>
</tr>
<tr>
<td>Layout Inflation</td>
<td style="text-align:center">NO<code>2</code></td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO<code>2</code></td>
<td style="text-align:center">NO<code>2</code></td>
<td style="text-align:center">NO<code>2</code></td>
</tr>
<tr>
<td>Start a Service</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>Bind to a Service</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>Send a Broadcast</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>Register BroadcastReceiver</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO<code>3</code></td>
</tr>
<tr>
<td>Load Resource Values</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p><strong>译者注</strong>：这1，2，3标注就不翻译了，说说我自己的理解吧。这几个Context只有Activity的Context是“看的见的”，其他组件的Context都是“看不见的”。因此，如果你想创建一个比如Dialog，Activity等“看的见”的组件就必须要用Activity的Context。比如，你想调用getString或getResource方法获取res文件夹下的资源时，所有的Context对象都可以使用。因为这些东西都是“看不见”的。</p>
<p><strong>“Show a Dialog”</strong> 这是我在公司亲身遇到过的一个问题，Dialog必须要依附于一个Activity组件，不然无法显示。</p>
<p><strong>“Start an Activity”</strong>这个与Activity运行的<a href="http://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="external">后退栈</a>有关系</p>
<p>##用户界面</p>
<p>你可以从上面的表格中看到<code>Application Context</code>有很多事情是做不了的，它不能做的事情都与UI有关。事实上，只有Activity才能够处理与UI有关的任务，其他的Context都是非常相似的（不能处理与UI有关的任务）。</p>
<p>这3个任务（“Show a Dialog”，“Start a Activity”，“Layout Inflation”）似乎就是Android系统就是这么设计的，让Activity来处理这些与UI有关的任务。想要使用Application Context对象来新建一个Dialog或者启动一个Activity系统就会抛出异常，然后程序就会崩溃。</p>
<p>Infalting layouts是一个容易被忽略的问题，如果你读过这篇文章<a href="http://www.doubleencore.com/2013/05/layout-inflation-as-intended/" target="_blank" rel="external">layout inflation</a>，你就会明白这里面隐藏着一些坑…使用不同的Context就是会带你走向不同坑。当你使用<em>LayoutInflator</em>，并且使用<code>Application Context</code>后，它会返回一个<code>View</code>，但是这个<code>View</code>的主题和样式就会被忽略。这是因为，<code>Activity</code> 才是系统配置文件中的唯一持有主题和样式的<code>Contex</code>t。其他所有的<code>Context</code>都会使用系统默认的主题来渲染你的xml来生成<code>View</code>，最终就导致了界面并不是你想要的。</p>
<p>##结论<br>很多情况下，你可以在一个组件内部使用Context对象，你可以很安全的持有Context的引用，前提就是你的对象生命周期小于Context的生命周期。如果你的对象需要持有一个比Context生命周期要长的Context引用时，即使你的对象也是一个临时对象，也请你考虑保存Application Context 的引用！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://www.doubleencore.com/2013/06/context/">http://www.doubleencore.com/2013/06/context/</a></p>
<p>###译者注：<br>找到一篇好文章，在开发过程中，经常会使用context对象，但是却不知道context是个什么东西，也不知道<code>getApplicationContext()</code> 和 <code>getContext()</code> 如何工作。特地翻译这篇文章，刚开始翻译，英语也不好，有错误还请大家指正。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="翻译" scheme="http://bxbxbai.gitcafe.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android要点：理解Loopers 和 Handlers]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/07/13/android%E8%A6%81%E7%82%B9%E7%90%86%E8%A7%A3looper%E5%92%8Chandler/"/>
    <id>http://bxbxbai.gitcafe.io/2014/07/13/android要点理解looper和handler/</id>
    <published>2014-07-13T09:01:13.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://mindtherobot.com/blog/159/android-guts-intro-to-loopers-and-handlers/" target="_blank" rel="external">http://mindtherobot.com/blog/159/android-guts-intro-to-loopers-and-handlers/</a></p>
<p>我喜欢Android的原因之一就是它有很多非常有用的小工具，其中很多还是与平台无关的。今天，我想介绍两个非常nice 的类——<code>Looper</code>和<code>Handler</code>，他们用于Android UI，并且对我们开发者也可用，我们就可以用它们来做很多非常棒的事情了。</p>
<a id="more"></a>
<p>那么，我们能用<code>Looper</code>和<code>Handler</code>做什么呢？首先，这两个类实现了一种通用的并发模型，我把它叫做：Pipeline 线程。它是这样工作的：</p>
<ol>
<li>Pipeline 线程持有一个任务队列（a queue of tasks），这些任务就是一些可以执行的工作单元（units of work）</li>
<li>其他线程可以自由的将任务加到Pipeline线程的任务队列中去</li>
<li>Pipeline线程就按次序一个一个执行任务，如果任务队列中没有任务了，它就会自动阻塞直到有任务到来</li>
<li>有些时候，任务可以叫做消息（messages）或者其他名字</li>
</ol>
<p>这个架构有一些很好的特征，并且这个架构已经被用于其他平台的框架或应用中了。</p>
<p>这篇文章中，我们会新建一个简单的app来模拟一个下载任务队列，同时在UI界面显示任务的状态，我们就直接使用Looper和Handler了。（源代码可以去原文中下载）</p>
<p>但是，我们在开始前先来看一下Pipeline线程，以及Looper和Handler的原理。</p>
<p>###Pipeline线程的用途<br>Pipeline线程的用途可以在几乎所有的UI框架中找到，包括Swing，SWT，Adobe Flex，以及Android Activity。Pipeline线程模式经常被用于处理UI事件（如按钮的点击事件，手指移动，屏幕方向改变，屏幕重新绘制等等），它可以让你在改变一个按钮文字的时候同时不用担心用户会点击这个按钮（译者注：这两个事件不会并发执行，处理UI事件是单线程的）。</p>
<p>另一方面，这就迫使你在UI线程中执行较快的操作——任何一个开发都知道如果你在一个按钮的<code>OnClick</code>方法中去下载一个文件会发生什么事情。</p>
<p>其他Pipeline线程模式的通用操作有：</p>
<ol>
<li>执行一个到远程服务的request（通常你希望它们一个一个按序执行） </li>
<li>上传一个图片到http服务器</li>
<li>缩放以及剪裁图片</li>
<li>下载操作</li>
</ol>
<p>通常，使用一个Pipeline线程而不是为每个后台操作都新建一个线程的好处就是，这样你可以控制每个后台任务的加载以及顺序（优先级）。此外，你也可以开启多个Pipeline线程，把他们当做一个线程池，这样你就可以一次同时执行多个操作。</p>
<p>###Looping和Handling<br><a href="http://developer.android.com/reference/android/os/Looper.html" target="_blank" rel="external">Looper</a>类可以将一个线程转换成Pipeline线程，而<a href="http://developer.android.com/reference/android/os/Handler.html" target="_blank" rel="external">Handler</a>提供了一种机制，你可以通过它将任务添加到Pipeline线程中。Looper之所以这么命名是因为它实现了循环——取一个task执行，然后再取下一个task执行，如此循环；Handler如此命名是因为他们无法想出一个更好的名字了~（译者注：囧…）</p>
<p>下面就是你需要添加到Thread类的run方法中的代码来创建一个你自己的Pipeline线程，然后可以将这个Pipeline线程添加到Handler对象中：</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
  <span class="keyword">try</span> {
    <span class="comment">// preparing a looper on current thread     </span>
    <span class="comment">// the current thread is being detected implicitly</span>
    Looper.prepare();

    <span class="comment">// now, the handler will automatically bind to the</span>
    <span class="comment">// Looper that is attached to the current thread</span>
    <span class="comment">// You don't need to specify the Looper explicitly</span>
    <span class="keyword">handler</span> = <span class="keyword">new</span> Handler();

    <span class="comment">// After the following line the thread will start</span>
    <span class="comment">// running the message loop and will not normally</span>
    <span class="comment">// exit the loop unless a problem happens or you</span>
    <span class="comment">// quit() the looper (see below)</span>
    Looper.loop();
  } <span class="keyword">catch</span> (Throwable t) {
    Log.e(TAG, <span class="string">"halted due to an error"</span>, t);
  } 
}
</code></pre><p>然后，你只要将这个handler对象传到其他任何线程中去，它有一个线程安全的接口，包括了很多操作，但是最主要的操作就是<code>postMessage()</code>以及相关的方法了。</p>
<p>#####Notes：Handler类包含了很多非常棒的方法，特别是与消息传递有关的，本文不会写与此相关的内容。</p>
<p>举个栗子：想象一下，一个线程A持有了handler对象的引用，此handler是在Pipeline线程中创建的，下面代码就可以让这个线程A在Pipeline线程中执行操作了：</p>
<pre><code><span class="keyword">handler</span>.post(<span class="keyword">new</span> Runnable() {
  <span class="annotation">@Override</span>
  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{       
    <span class="comment">// this will be done in the Pipeline Thread       </span>
  }
});
</code></pre><p>在下载的栗子中，我们就会在用户点击按钮（在UI线程中处理）的时候，用这个模板来创建一个下载任务（在下载Pipeline线程中）。我们还用另外一种方式用它——当下载线程下载完成以后会通知Activity，因此在创建下载线程的时候，我们会将Activity中的UI线程handler对象传给它。</p>
<p>此外，UI线程拥有一个Looper（译者注：可以通过Looper.getMainLooper()方法获取，判断一个线程是否为主线程可以使用Looper.getLooper() == Looper.getMainLooper()来判断）。所以，你可以在Activity的onCreate()方法中直接新建一个handler对象：</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    <span class="comment">// Create the Handler. It will implicitly bind to the Looper</span>
    <span class="comment">// that is internally created for this thread (since it is the UI thread)</span>
    <span class="keyword">handler</span> = <span class="keyword">new</span> Handler();
}
</code></pre><p>###结论<br>Looper和Handler可以让你很方便的做很多事情，然而他们与并发相关，这就会变得很复杂。</p>
<p>####译者注：<br>Looper和Handler是非UI线程更新界面的重要方式，在非UI线程中通过下面代码：</p>
<pre><code><span class="keyword">new</span> Handler(Looper.myLooper()).post(<span class="keyword">new</span> Runnable() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="comment">//在UI线程中处理 </span>
    }
});
</code></pre><p>就可以轻松的将一些工作放到UI线程中处理，比如进度条刷新等等。</p>
<p>####附件：<a href="http://mindtherobot.com/blog/wp-content/uploads/2010/06/downloadqueue.zip" target="_blank" rel="external">完整源代码</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://mindtherobot.com/blog/159/android-guts-intro-to-loopers-and-handlers/">http://mindtherobot.com/blog/159/android-guts-intro-to-loopers-and-handlers/</a></p>
<p>我喜欢Android的原因之一就是它有很多非常有用的小工具，其中很多还是与平台无关的。今天，我想介绍两个非常nice 的类——<code>Looper</code>和<code>Handler</code>，他们用于Android UI，并且对我们开发者也可用，我们就可以用它们来做很多非常棒的事情了。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发技巧" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
      <category term="翻译" scheme="http://bxbxbai.gitcafe.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[防御性编程以及我的一些感想]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/06/11/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%88%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/"/>
    <id>http://bxbxbai.gitcafe.io/2014/06/11/防御性编程以及我的一些感想/</id>
    <published>2014-06-11T12:36:49.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>##这得从我看到的这篇文章说起~<br><a href="http://sharecore.net/blog/2014/01/13/defensive-programming/" target="_blank" rel="external">防御性编程小例</a>，最开始我是关注了这个人的微信，才看到这篇文章的，最近也工作了一段时间了~对自己以及别人写的代码有了一些新的想法（因为我遇到过很多坑啊囧）。因此，本文来谈谈这个话题。</p>
<a id="more"></a>
<p>在公司，我们碰到的很大一部分问题都是<code>NullPointerException</code>。我常常就想：<strong>这段程序明明在我手机上运行好好的，为什么会出现这种情况呢？</strong></p>
<p><strong>因为，我们永远都无法预测用户使用App时会发生的各种情况。</strong>所以防御性编程可以让我们减少很大一部分错误。</p>
<p>##先说一个故事<br>先来说一个我去年面试过的问题，面试官问我：<strong>请你用最熟悉的语言写一个atoi程序。</strong></p>
<p>我心里一想：这么简单！！我要好好写！不要写出bug！我马上就写好了，并且用“12334”这种简单的字符串试了又试，没问题就交给他看。</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">atoi</span><span class="params">(String a)</span></span>{
    <span class="keyword">int</span> len = a.length();
    <span class="keyword">int</span> num = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {
        num += (a.charAt(i) - <span class="string">'0'</span>) * Math.<span class="built_in">pow</span>(<span class="number">10</span>, len - i - <span class="number">1</span>);
    }
    <span class="keyword">return</span> num;
}
</code></pre><p>面试官一看就问我，你找找有什么问题没，我看了好几遍（我都在找bug），说没问题啊！我又仔细一想：如果传进来一个负数怎么办呢？比如“-12333”，这段程序就错了！</p>
<p>我就和面试官说了~他说嗯，还有问题吗？我心里想还有啊？想了几遍都想不出！我说：效率问题？他不给面子直接就说：你先别管效率！</p>
<p><strong>他说如果我传进来一个<code>null</code>会怎么样？我恍然大悟！！！我有太多东西没考虑到(我图样图森破啊囧！！)！</strong></p>
<p>上面就是我的一个真实的故事~不知你看了有什么感想，反正我觉得这次面试可以让我反思很多我存在的问题。</p>
<p>自从看了前面提到的那篇文章后，我现在写代码就时刻装着“防御性编程”这5个字。</p>
<p>##那么怎么写防御性代码呢？</p>
<p>请看<code>Integer.parseInt(String)</code>这个方法，好好看！我现在分析一下~JDK的大神们怎么写健壮的代码！（如果有错误请指正~ =.=）</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String <span class="built_in">string</span>, <span class="keyword">int</span> radix)</span> throws NumberFormatException </span>{
    <span class="keyword">if</span> (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX) {
        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"Invalid radix: "</span> + radix);
    }
    <span class="keyword">if</span> (<span class="built_in">string</span> == null) {
        <span class="keyword">throw</span> invalidInt(<span class="built_in">string</span>);
    }
    <span class="keyword">int</span> length = <span class="built_in">string</span>.length(), i = <span class="number">0</span>;
    <span class="keyword">if</span> (length == <span class="number">0</span>) {
        <span class="keyword">throw</span> invalidInt(<span class="built_in">string</span>);
    }
    boolean negative = <span class="built_in">string</span>.charAt(i) == <span class="string">'-'</span>;
    <span class="keyword">if</span> (negative &amp;&amp; ++i == length) {
        <span class="keyword">throw</span> invalidInt(<span class="built_in">string</span>);
    }

    <span class="keyword">return</span> parse(<span class="built_in">string</span>, i, radix, negative);
}
</code></pre><p>上面这段代码出自java 1.7.0_51的<code>java.lang.Integer</code>类，JDK开发大神是如何写代码的呢？</p>
<p>可以看到这段代码最开始的一部分就是在验证每个参数的正确性（代码中radix表示进制数），这里最小的进制就是2，最大进制是36。如果进制数不满足要求，直接抛出异常。</p>
<p>然后判断传入字符串是否为<code>null</code>，如果字符串不为<code>null</code>，然后可以取字符串的长度。 后面再判断字符串是否一个负数， 当所有参数都验证过了以后再做正事——<strong>将字符串转换成一个数字</strong>。</p>
<h3 id="我现在得到的一个重要的经验就是：">我现在得到的一个重要的经验就是：</h3><p><strong>当你写一个方法需要对传入的参数进行处理或者计算的时候，你必须要严格验证传入参数的正确性，如果不符合，就应当给出提示！</strong></p>
<p>上面提到的那篇文章里说到：</p>
<blockquote>
<p>这就是防御性编程的最基本规则：保护程序免遭非法输入数据的破坏。</p>
</blockquote>
<p>这些都是我以前编程不会考虑的事情啊！</p>
<p>如果你的代码没有防御性措施，那么你一定会遇到各种坑的~只是时候未到~</p>
<p>但也不是说所有的程序都应该这么写。<strong>如果你在写一个private方法只供类里面使用，那么我觉得就不必写这种防御性代码了。</strong>当然没有绝对的事情，如果一个public方法接受外部传入的参数，这个参数又传入这个private方法，那么你在使用这个private方法时候就需要先验证参数的合法性，然后再调用这个private方法。</p>
<p>当你在写一个public方法可以接受来自任何地方的参数时，就必须要验证参数的合法性了！</p>
<p>##那么为什么要防御性编程<br>我觉得最终的目的就是为了让你写的代码正确运行，当面对各种各样的参数时，同时要向外部提供参数错误的原因，可以快速找到bug。</p>
<p>在Android开发里面，主线程（UI线程）中的一个微小的问题都会导致程序的崩溃，可能是一不小心一个View对象传入某个方法的时候是一个<code>null</code>，也可能一个方法的返回值是<code>null</code>等等，各种坑会在隐藏的地方等着你来踩哦~</p>
<p>要知道当一个对象为<code>null</code>的时候（你肯定不知道它为<code>null</code>），然后调用它的方法时，就会发生程序崩溃，这是应该是程序崩溃最常见的原因之一了~</p>
<p>比如在我最开始写的那个atoi程序里，如果别人用我的程序不小心传入一个<code>null</code>，那么我的程序就崩溃了~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>##这得从我看到的这篇文章说起~<br><a href="http://sharecore.net/blog/2014/01/13/defensive-programming/">防御性编程小例</a>，最开始我是关注了这个人的微信，才看到这篇文章的，最近也工作了一段时间了~对自己以及别人写的代码有了一些新的想法（因为我遇到过很多坑啊囧）。因此，本文来谈谈这个话题。</p>]]>
    
    </summary>
    
      <category term="经验" scheme="http://bxbxbai.gitcafe.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android应用程序创建热点以及自动链接Wifi，我遇到的问题以及我是怎么解决的]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/05/22/android-wifi-connection/"/>
    <id>http://bxbxbai.gitcafe.io/2014/05/22/android-wifi-connection/</id>
    <published>2014-05-22T14:24:02.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>急速传歌这个功能需要App能够自动去连接另一个手机创建的热点，本文先说Wifi创建热点以及连接Wifi的原理，然后再讲我遇到的问题和我是怎么解决问题的。</p>
<p>B手机创建热点是一个自动的过程，A手机去连接B手机的热点也是一个自动的过程，此时手机B充当路由器的角色。</p>
<a id="more"></a>
<p>自动连接Wifi功能，就像我们通过系统设置WLAN里面，选择一个Wifi并且输入密码（如果有密码）的过程一样，只不过App知道了这个Wifi（带某个前缀）的密码，然后通过相关设置，可以自动去连接。</p>
<h2 id="Android应用如何自动链接Wifi">Android应用如何自动链接Wifi</h2><p>Android开发里操作Wifi功能的api就在<code>android.net.wifi.WifiManager</code>这个类中，包括：</p>
<ul>
<li><code>getConnectionInfo()</code> 获取当前Wifi连接信息，返回<code>WifiInfo</code>对象，包括<code>SSID</code>，<code>BSSID</code>，<code>networkId</code>，<code>ipAddress</code>，<code>macAddress</code>等信息</li>
<li><code>disableNetwork(int netId)</code>  禁用这个network（即使Wifi扫描到这个热点也不会主动去连接），参数<code>netId</code>就是<code>WifiInfo</code>中的<code>networkId</code>值</li>
<li><code>disconnect()</code>  断开当前连接</li>
<li><code>getConfiguredNetworks()</code> 返回已经保存的Wifi网络列表，返回值是<code>List&lt;WifiConfiguration&gt;</code></li>
<li><code>updateNetwork(WifiConfiguration config)</code> 更新Wifi配置，比如更新密码或网络的优先级</li>
<li><code>addNetwork(WifiConfiguration config)</code> 添加一个新的Wifi配置，当我们在<strong>设置-&gt;WLAN</strong>中选择一个网络并输入密码连接后，系统会自动帮我们记住这个网络，这个方法返回<code>int</code>，是<code>networkId</code>值</li>
<li><code>enableNetwork(int netId, boolean disableOthers)</code>  调用这个方法后，一般手机会去自动去连接这个wifi网络，但是部分手机会连接失败</li>
<li><code>saveConfiguration()</code>; 部分手机的连接失败</li>
<li><code>reconnect()</code>;</li>
</ul>
<h2 id="Android应用如何创建一个热点">Android应用如何创建一个热点</h2><p>Android开发中，创建热点的方法也是在<code>WifiManager</code>类中，不过都已经被Google <code>@hide</code>了。</p>
<blockquote>
<p><code>@hide</code> annotation就是Google隐藏了不稳定的方法，当稳定之后，自然会公开，如果我们现在要用这些方法，那么必须通过Java反射来调用</p>
</blockquote>
<p>创建一个热点最重要的就是：配置一个<code>WifiConfiguration</code> 对象，通过配置</p>
<ul>
<li><code>SSID</code>: 热点的名字 </li>
<li><code>preSharedKey</code>  热点密码 </li>
<li><code>hiddenSSID</code>： 是否隐藏SSID</li>
<li><code>status</code>：是否启用这个热点配置</li>
<li><code>allowedAuthAlgorithms</code>：IEEE 802.11认证算法 OPEN</li>
<li><code>allowedGroupCiphers</code> ：组秘钥TKIP+CCMP</li>
<li><code>allowedPairwiseCiphers</code>：对称秘钥TKIP+CCMP</li>
<li><code>allowedKeyManagement</code>：秘钥管理WPA_PSK</li>
<li><code>allowedProtocols</code>：加密协议WPA+RSN</li>
</ul>
<p>启动热点也需要通过Java反射调用<code>WifiManager</code>类中的<code>setWifiApEnabled(WifiConfiguration wifiConfig, boolean enabled)</code>方法，第一个参数就是前面配置的<code>WifiConfiguration</code>对象，第二个参数<code>true</code>表示打开，<code>false</code>表示关闭热点。</p>
<p>当时连接wifi的主要的代码就是，先配置好<code>WifiConfiguration</code>对象，然后就是添加向添加一个<code>WifiConfiguration</code>，这样就会返回这个Wifi配置的<code>id</code>，然后就<code>enable</code>这个Wifi配置，到此为止，一般的手机都可以连接成功</p>
<pre><code><span class="keyword">int</span> networkId = mWifiManager.addNetwork(wifiConfig);

<span class="keyword">boolean</span> enabled = mWifiManager.enableNetwork(networkId, <span class="keyword">true</span>);
</code></pre><h2 id="我遇到的第一个问题：">我遇到的第一个问题：</h2><p>手机A不能自动的去连接手机B创建的热点，那么问题是手机B创建的热点有问题还是手机A连接热点的配置信息有问题？但是手机C又可以去连接手机B的热点，那么是否说明手机B的热点创建就没问题了呢？</p>
<p>试了很多手机之后，发现都可以连接到手机B的热点，那么我们初步判定就是手机A 的连接Wifi配置信息有问题！后来，我就用手机A系统设置里的Wifi连接功能去连接手机B的热点，可以连接！那么问题就是手机A 连接热点的配置有问题！</p>
<p>问题又来了：</p>
<p>同样的Wifi配置信息，为什么大部分手机都可以连接热点成功，而一些手机就不可以呢？而连接Wifi的方法都是在<code>WifiMnager</code>类中<br>我看到了一个方法<code>public void connect(WifiConfiguration config, ActionListener listener)</code>方法，看文档就是用来连接Wifi的！！！！但不幸的是，这个方法被<code>@hide</code>了！！！！肯跌啊@_@还好，在文档中可以看到：</p>
<blockquote>
<p>For a new network, this function is used instead of a sequence of <code>addNetwork()</code>, <code>enableNetwork()</code>, <code>saveConfiguration()</code> and <code>reconnect()</code></p>
</blockquote>
<p>而这4个方法是pulic并且没有<code>@hide</code>的！！然后按照文档写的，再添加两行代码：</p>
<pre><code>非常关键的两行代码，有些手机必须要在<span class="tag">saveConfiguration</span>操作之后才能成功连接热点

<span class="tag">mWifiManager</span><span class="class">.saveConfiguration</span>();
<span class="tag">mWifiManager</span><span class="class">.reconnect</span>();
</code></pre><p>手机A就可以连接成功了！！</p>
<h2 id="我遇到的第二个问题：">我遇到的第二个问题：</h2><p>HTC手机创建热点时热点的配置信息中的热点名字不起作用！HTC手机可以成功自动连接Wifi，也可以创建热点，但是不能改热点的名字！！这就导致了其他所有手机都不能自动连HTC手机的热点！那么问题显而易见就是创建热点的时候信息配置有问题！！那么为什么配置有问题呢？其他手机不是都可以的吗？</p>
<p>问题大致已经找到了，但是为什么这样呢？必须求助强大的Google了~~~经过一番搜索之后重要找到了！！！</p>
<p><a href="http://blog.sina.com.cn/s/blog_53dd443a010109i8.html" target="_blank" rel="external">WIFI热点设置,htc setWifiApEnabled Wificonfiguration</a><br><a href="http://www.cnblogs.com/shangdawei/archive/2013/03/22/2974682.html" target="_blank" rel="external">HTC 通过 WifiConfiguration 修改 SSID</a></p>
<p>原因就在于: <strong>HTC就喜欢自己去改一些Android系统的api</strong>，导致很多手机都可以正常运行的功能，到了HTC手机上就不能正常运行了！！！这不是肯跌吗？(╯‵□′)╯︵┻━┻</p>
<p>找到原因也找到了解决办法，这个bug就这么愉快的解决了~真的多谢强大的Google啊~~</p>
<h2 id="说到最后">说到最后</h2><p>我们做事情过程中，一定会遇到很多各种各样的问题，</p>
<blockquote>
<p>找到问题的原因（为什么会这样）比怎样去解决重要的多<br>怎样把大象放进冰箱呢？ 打开冰箱，然后把大象放进去！</p>
</blockquote>
<p><strong>怎么解决问题呢？</strong><br>先找到问题的原因，然后在找解决问题的办法</p>
<p>还是那句话，找到问题的原因比找到解决问题的办法更重要.</p>
<p>找到问题所在的原因，如果你不能解决，那么你可以求助于其他人，而当你不知道问题的原因的时候，你去求助别人的时候，别人还有帮你去找问题的原因，这肯定会浪费很多时间的。先不要找解决问题的办法，先找问题的原因~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>急速传歌这个功能需要App能够自动去连接另一个手机创建的热点，本文先说Wifi创建热点以及连接Wifi的原理，然后再讲我遇到的问题和我是怎么解决问题的。</p>
<p>B手机创建热点是一个自动的过程，A手机去连接B手机的热点也是一个自动的过程，此时手机B充当路由器的角色。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://bxbxbai.gitcafe.io/tags/Android/"/>
    
      <category term="开发技巧" scheme="http://bxbxbai.gitcafe.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 原型继承]]></title>
    <link href="http://bxbxbai.gitcafe.io/2014/01/17/javascript-prototype/"/>
    <id>http://bxbxbai.gitcafe.io/2014/01/17/javascript-prototype/</id>
    <published>2014-01-16T16:00:00.000Z</published>
    <updated>2015-09-12T07:01:41.000Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://javascript.info/tutorial/inheritance" target="_blank" rel="external">JavaSccript Prototype</a></p>
<pre><code><span class="bullet">1. </span>Inheritance, the <span class="strong">__proto__</span>
<span class="bullet">2. </span>Object.create, Object.getPrototypeOf
<span class="bullet">3. </span>The prototype
<span class="bullet">4. </span>Crossbrowser Object.create(proto)
<span class="bullet">5. </span>hasOwnProperty
<span class="bullet">6. </span>Looping with/without inherited properties
<span class="bullet">7. </span>Summary
</code></pre><blockquote>
<p>在JavaScript中，“一切都是对象，函数是第一型”，Function和Object都是函数的实例。其实整个Javascript的核心体系结构都是围绕着这两个构造函数来构建的。</p>
</blockquote>
<a id="more"></a>
<p>大多数编程语言中，都有类和对象，一个类可以继承其他类。<br>在JavaScript中，继承是基于原型的（prototype-based），这意味着JavaScript中没有类，取而代之的是一个对象继承另一个对象。：）</p>
<p><strong>1. 继承, the <strong>proto</strong></strong></p>
<p>在JavaScript中，当一个对象rabbit继承另一了对象<code>animal</code>时，这意味着<code>rabbit</code>对象中将会有一个特殊的属性：<code>rabbit.__proto__ = animal;</code></p>
<p>当访问<code>rabbit</code>对象时，如果解释器在<code>rabbit</code>中不能找到属性，那么它会顺着<code>__proto__</code>链往上在<code>animal</code>对象中寻找<br>栗子中的<code>__proto__</code>属性仅在Chrome和FireFox中可以访问，请看一个栗子：</p>
<pre><code>var <span class="keyword">animal</span> = { eats: true }
var rabbit = { jumps: true }

rabbit.__proto__ = <span class="keyword">animal</span>  // inherit

alert(rabbit.eats) // true
</code></pre><p><code>eats</code>属性是从<code>animal</code>对象中访问的。</p>
<p>如果在rabbit对象中已经发现了属性，那么就不会去检查<strong>proto</strong>属性啦。</p>
<p>再来一个栗子，当子类中也有<code>eats</code>属性时，父类中的就不会访问了。</p>
<pre><code>var <span class="keyword">animal</span> = { eats: true }
var fedUpRabbit = { eats: false}

fedUpRabbit.__proto__ = <span class="keyword">animal</span> 

alert(fedUpRabbit.eats) // false
</code></pre><p>你也可以在<code>animal</code>中添加一个函数，那么在<code>rabbit</code>中也可以访问了。</p>
<pre><code>var <span class="keyword">animal</span> = {
  eat: function() {
    alert( <span class="string">"I'm full"</span> )
    this.full = true
  }
}


var rabbit = {
  jump: function() { /* something */ }
}

rabbit.__proto__ = <span class="keyword">animal</span> 

rabbit.eat() 
</code></pre><p><code>rabbit.eat()</code>函数以如下两步执行：</p>
<ol>
<li><p>首先，解释器查找<code>rabbit.eat</code>，<code>rabbit</code>中没有<code>eat</code>函数，那么它就顺着<code>rabbit.__proto__</code>往上找，在<code>animal</code>中找到了。</p>
</li>
<li><p>函数以<code>this = rabbit</code>运行。<code>this</code>值与<code>__proto__</code>属性完全无关。</p>
</li>
</ol>
<p>因此，<code>this.full = true</code>在<code>rabbit</code>中：</p>
<p>看看这里我们有什么新发现，一个对象调用了父类函数，但是this还是指向对象本身，这就是继承。</p>
<p>被<code>__proto__</code>引用的对象称作是原型（<code>prototype</code>），<code>animal</code>是<code>rabbit</code>的原型（译者注：这就是<code>rabbit</code>的<code>__proto__</code>属性引用了<code>animal</code> 的<code>prototype</code>属性）</p>
<p>读时查找，不是写时<br>当读取一个对象时，比如<code>this.prop</code>，解释器会在它的原型中查找属性。<br>当设置一个属性值时，比如<code>this.prop = value</code>，那么就没有理由去查找了，这个属性（prop）会被直接添加到这个对象中（这里是this）。<code>delete obj.prop</code>也类似，它只删除对象本身的属性，原型中的属性保持原封不动。</p>
<p>关于<strong>proto</strong><br>如果你在阅读指南，这里我们叫的<code>__proto__</code>，在指南中表示为[[Prototype]]。双方括号是很重要的，因为有另一个属性叫做<code>prototype</code></p>
<p><strong>2. Object.create, Object.getPrototypeOf</strong></p>
<p><code>__proto__</code>是一个非标准的属性，由Chrome/FireFox提供访问，在其他的浏览器中保持不可见。</p>
<p>所有的现代浏览器除了Opera（IE &gt; 9）支持两个标准的函数来处理原型问题：</p>
<p>Object.ceate(prop[,props])<br>用给定了<strong>proto</strong>创建一个空对象：</p>
<pre><code>var <span class="keyword">animal</span> = { eats: true }

rabbit = Object.create(<span class="keyword">animal</span>)

alert(rabbit.eats) // true
</code></pre><p>上面代码创建了一个空<code>rabbit</code>对象，并且原型设置为<code>animal</code></p>
<p><code>rabbit</code>对象创建好以后，我们可以往里添加属性了：</p>
<pre><code>var <span class="keyword">animal</span> = { eats: true }

rabbit = Object.create(<span class="keyword">animal</span>)
rabbit.jumps = true
</code></pre><p><code>Object.creat</code>函数的第二个参数<code>props</code>是可选的，它允许像新对象设置属性。这里就省略了，因为我们关系的继承。</p>
<p><strong>Object.getPrototypeOf(obj)</strong><br>返回<code>obj.__proto__</code>的值。这个函数是标准的，可以在不能直接访问<code>__proto__</code>属性的浏览器中使用了。</p>
<pre><code>var <span class="keyword">animal</span> = {
  eats: true
}

rabbit = Object.create(<span class="keyword">animal</span>)

alert( Object.getPrototypeOf(rabbit) === <span class="keyword">animal</span> ) // true
</code></pre><p>现代浏览器允许读取<code>__proto__</code>属性值，但是不能设置。</p>
<p><strong>3. The prototype</strong><br>有一些好的跨浏览器的方式设置<code>__proto__</code>属性，这将会使用构造器函数（constructor functions）。记住！任何函数创建一个对象都是通过<code>new</code>关键字的。</p>
<p>一个栗子：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span><span class="params">(name)</span> </span>{
  <span class="keyword">this</span>.name = name
}

<span class="keyword">var</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">'John'</span>)

alert(rabbit.name) <span class="comment">// John</span>
</code></pre><p><code>new</code>操作将原型的属性设置到<code>rabbit</code>对象的的<code>__proto__</code>属性中了。<br>让我们来看看它的原理，例如，<code>new Rabbit</code> 对象，而<code>Rabbit</code>是继承<code>animal</code> 的。</p>
<pre><code>var <span class="keyword">animal</span> = { eats: true }

function Rabbit(name) {
  this.name = name
}

Rabbit.prototype = <span class="keyword">animal</span>

var rabbit = new Rabbit('John')

alert( rabbit.eats ) // true, because rabbit.__proto__ == <span class="keyword">animal</span>
</code></pre><p><code>Rabbit.prototype = animal</code> 字面量意味着：对所有由<code>new Rabbit</code>创建的对象设<code>__proto__ = animal</code> </p>
<p><strong>4。 跨浏览器 <code>Object.create(proto)</code></strong><br><code>Object.create(prop)</code>函数功能的强大的，因为它允许从给定的对象直接继承。它可以由如下代码模拟：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(proto)</span> </span>{
  <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>{}
  F.prototype = proto
  <span class="keyword">return</span> <span class="keyword">new</span> F
}
</code></pre><p><code>inherit(animal</code>) 与<code>Object.create(animal)</code>是完全等同的，返回一个空的对象，并且<code>object.__proto__ = animal</code>。</p>
<p>一个栗子：</p>
<pre><code>var <span class="keyword">animal</span> = { eats: true }

var rabbit = inherit(<span class="keyword">animal</span>)

alert(rabbit.eats) // true
alert(rabbit.hasOwnProperty('eats')) // false, from prototype
</code></pre><p>来看一下它的原理是什么：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">proto</span>) </span>{
  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>{}     <span class="comment">// (1)</span>
  F.prototype = proto <span class="comment">// (2)</span>
  <span class="keyword">return</span> <span class="keyword">new</span> F()      <span class="comment">// (3)</span>
}

<span class="number">1.</span> 创建了一个新函数，函数没有向<span class="keyword">this</span>设置任何属性，以此<span class="string">`new F`</span> 会创建一个空对象。
<span class="number">2.</span> <span class="string">`F.prototype`</span>被设置为proto
<span class="number">3.</span> <span class="string">`new`</span> F创建了一个空对象，对象的<span class="string">`__proto__ = F.prototype`</span> 
<span class="number">4.</span> Bingo! 我们得到了一个继承<span class="string">`proto`</span>的空对象
</code></pre><p> 这个函数广泛适用于各种库和框架之中。</p>
<p>你的函数接受了一个带有options 的对象</p>
<pre><code><span class="comment">/* options contains menu settings: width, height etc */</span>
<span class="function"><span class="keyword">function</span> <span class="title">Menu</span><span class="params">(options)</span> </span>{
  <span class="comment">// ...</span>
}
</code></pre><p>你想设置某些options</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Menu</span><span class="params">(options)</span> </span>{
  options.width = options.width || <span class="number">300</span> <span class="comment">// set default value</span>
  <span class="comment">// ...</span>
}
</code></pre><p>。。。但是改变参数值可能会产生一些错误的结果，因为options可能会在外部代码中使用。一个解决办法就是克隆options对象，复制所有的属性到一个新的对象中，在新对象中修改，</p>
<p>怎样用继承来解决这个问题呢？ P.S. options可以添加设设置，但是不能被删除。</p>
<p>Solution<br>你可以继承options，并且在它的子类的中修改或者添加新的属性。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(proto)</span> </span>{
  <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>{}
  F.prototype = proto
  <span class="keyword">return</span> <span class="keyword">new</span> F
}

<span class="function"><span class="keyword">function</span> <span class="title">Menu</span><span class="params">(options)</span> </span>{
  <span class="keyword">var</span> opts = inherit(options)
  opts.width = opts.width || <span class="number">300</span>
  <span class="comment">// ...</span>
}
</code></pre><p>所有的操作只在子对象中有效，当Menu方法结束时，外部代码仍然可以使用没有修改的过的options对象。<code>delete</code>操作在这里非常重要，如果width是一个prototype中的属性，<code>delete opts.width</code>不会产生任何作用</p>
<p><strong>5. hasOwnProperty</strong></p>
<p>所有的对象都有<code>hasOwnProperty</code>函数，它可以用来检测一个属性是否对象自身还是属于原型</p>
<p>一个栗子：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span><span class="params">(name)</span> </span>{
  <span class="keyword">this</span>.name = name
}

Rabbit.prototype = { eats: <span class="literal">true</span> }

<span class="keyword">var</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">'John'</span>)

alert( rabbit.hasOwnProperty(<span class="string">'eats'</span>) ) <span class="comment">// false, in prototype</span>

alert( rabbit.hasOwnProperty(<span class="string">'name'</span>) ) <span class="comment">// true, in object</span>
</code></pre><p><strong>6. Looping with/without inherited properties</strong></p>
<p><code>for..in</code>循环输出一个对象的所有属性，包括自身的和原型的。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span><span class="params">(name)</span> </span>{
  <span class="keyword">this</span>.name = name
}

Rabbit.prototype = { eats: <span class="literal">true</span> }

<span class="keyword">var</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">'John'</span>)

<span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> rabbit) {
  alert (p + <span class="string">" = "</span> + rabbit[p]) <span class="comment">// outputs both "name" and "eats"</span>
}
</code></pre><p>用<code>hasOwnProperty</code>可以过滤得到属于对象自己的属性：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Rabbit</span><span class="params">(name)</span> </span>{
  <span class="keyword">this</span>.name = name
}

Rabbit.prototype = { eats: <span class="literal">true</span> }

<span class="keyword">var</span> rabbit = <span class="keyword">new</span> Rabbit(<span class="string">'John'</span>)

<span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> rabbit) {
  <span class="keyword">if</span> (!rabbit.hasOwnProperty(p)) <span class="keyword">continue</span> <span class="comment">// filter out "eats"</span>
  alert (p + <span class="string">" = "</span> + rabbit[p]) <span class="comment">// outputs only "name"</span>
}
</code></pre><p><strong>7. Summary</strong></p>
<p><strong>JavaScript是通过一个特殊的属性<strong>proto</strong>来实现继承的</strong></p>
<ul>
<li>当访问一个对象的属性时，如果解释器不能在对象中找到，它就会去对象的原型中继续寻找 对函数属性来说，<code>this</code>指向这个对象，而不是它的原型。<br>赋值<code>obj.prop = value</code>， 删除<code>delete obj.prop</code></li>
</ul>
<p><strong>管理<strong>proto</strong>:</strong></p>
<ul>
<li>Chrome和FireFox可以直接访问对象的<code>__proto__</code>属性，大多数现代浏览器支持用<code>Object.getPrototypeOf(obj)</code>只读访问。<br><code>Object.create(proto)</code> 可以用给定的<code>proto</code>生成空的子对象，或者通过如下代码达到相同的功能：</li>
</ul>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inherit</span><span class="params">(proto)</span> </span>{
     <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>{}     
     F.prototype = proto
     <span class="keyword">return</span> <span class="keyword">new</span> F()    
   }
</code></pre><p><strong>其他方法：</strong></p>
<ul>
<li>for..in循环输出一个对象的所有属性（包括自身的和原型的）和对象的原型链。<br>如果一个属性prop属于对象<code>ob</code>j那么<code>obj.hasOwnProperty(prop)</code>返回true，否则返回false。</li>
</ul>
<p>参考：<br><a href="http://www.benben.cc/blog/?p=320" target="_blank" rel="external">http://www.benben.cc/blog/?p=320</a><br><a href="http://www.douban.com/note/184109636/" target="_blank" rel="external">http://www.douban.com/note/184109636/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://javascript.info/tutorial/inheritance">JavaSccript Prototype</a></p>
<pre><code><span class="bullet">1. </span>Inheritance, the <span class="strong">__proto__</span>
<span class="bullet">2. </span>Object.create, Object.getPrototypeOf
<span class="bullet">3. </span>The prototype
<span class="bullet">4. </span>Crossbrowser Object.create(proto)
<span class="bullet">5. </span>hasOwnProperty
<span class="bullet">6. </span>Looping with/without inherited properties
<span class="bullet">7. </span>Summary
</code></pre><blockquote>
<p>在JavaScript中，“一切都是对象，函数是第一型”，Function和Object都是函数的实例。其实整个Javascript的核心体系结构都是围绕着这两个构造函数来构建的。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="js" scheme="http://bxbxbai.gitcafe.io/tags/js/"/>
    
      <category term="技术" scheme="http://bxbxbai.gitcafe.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
